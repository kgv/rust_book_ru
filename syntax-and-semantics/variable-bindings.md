% Связывание переменных

Любая реальная не ’Hello World’ программа на Rust использует *связывание
переменных*. Это выглядит так:

```rust
fn main() {
    let x = 5;
}
```

Все операции производимые ниже будут происходить в функции `main()`, так как
каждый раз вставлять в примеры `fn main() {` немного утомляет. Убедитесь, что
примеры, приведённые в этом разделе, вы вводите в функцию `main()`, иначе можете
получить ошибку при компиляции.

Во многих языках программирования это называется *переменная*. Но у связывания
переменных в Rust есть пара трюков в рукаве. В левой стороне выражения `let`
располагается не просто имя переменной, а ‘[шаблон][pattern]’. Это значит, что
мы можем делать вещи вроде этой:

```rust
let (x, y) = (1, 2);
```

После завершения этого выражения `x` будет единицей, a `y` - двойкой. Шаблоны
очень мощны, и для них выделена отдельная [глава][pattern]. Но на данный момент
нам не нужны эти фичи, так что мы просто будем помнить о них и пойдём дальше.

[pattern]: patterns.html

Rust - статически типизированный язык программирования, и значит мы
должны указывать типы и они будут проверяться во время сборки. Так почему же наш 
первый пример собрался? В Rust'е есть такая вещь, как *вывод типов*. Если Rust 
самостоятельно может понять какой тип у переменной, то он не требует указывать его.

Тем не менее, мы можем указать желаемый тип. Он следует после двоеточия (`:`):

```rust
let x: i32 = 5;
```

Если бы я попросил вас прочитать это вслух, то вы бы сказали "`x` связан с типом
`int` и имеет значение `пять`".

В этом случае мы указали, что `x` у нас будет 32-битным целым числом со знаком. 
В Rust есть и другие целочисленные типы. Они начинаются с `i` для целых чисел со
знаком и с `u` для целых чисел без знака. Размер целых чисел может составлять 8,
16, 32 и 64 бита.

В дальнейших примерах мы будем указывать тип в комментариях. Это будет выглядеть
вот так:

```rust
fn main() {
    let x = 5; // x: i32
}
```

Обратите внимание на сходство между этим комментарием и синтаксисом, который вы
используете с `let`. Включение такого типа комментариев не является
идеоматическим для Rust, но иногда мы будем включать их для того, чтобы помочь
вам понять, какие типы будут выведены Rust.

По умолчанию, связывание *неизменяемо*. Этот код не скомпилируется:

```rust,ignore
let x = 5;
x = 10;
```

И вы получите ошибку:

```text
error: re-assignment of immutable variable `x`
     x = 10;
     ^~~~~~~
```

Если вы хотите чтобы связывание было изменяемым, вы можете использовать
модификатор `mut`:

```rust
let mut x = 5; // mut x: i32
x = 10;
```

Может показаться, что нет ни одной причины делать связывание неизменяемым по
умолчанию, но вспомните на чём в первую очередь сфокусирован Rust: на
безопасности. Если вы случайно забыли указать `mut` и изменили связывание,
компилятор заметит это, и сообщит вам, что вы изменили то, что возможно не
собирались менять. Если бы по умолчанию связывание было изменяемым, то в
приведённой выше ситуации компилятор не сможет вам помочь. Если вы намерены
изменить значение переменной, то просто добавьте `mut`.

Есть и другие весомые аргументы в пользу правила: по возможности, избегать
изменяемых состояний, но это выходит за рамки данного руководства. В общем,
зачастую вы можете избежать явных изменений, и это предпочтительнее в Rust. Тем
не менее, иногда без изменения значения просто не обойтись, так что это не
запрещено.

Вернёмся к связыванию. Связывании переменных в Rust имеет ещё одно отличие от
других языков: оно требует инициализации перед использованием.

Давайте приступим к рассмотрению вышесказаного. Измените ваш файл `src/main.rs`
так, что бы он выглядел следующим образом:

```rust
fn main() {
    let x: i32;

    println!("Hello world!");
}
```

Используйте команду `cargo build` в командной строке чтобы собрать проект. Вы
должны получить предупреждение, но программа будет работать и будет выводить
строку "Hello, world!":

```text
   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]
   on by default
src/main.rs:2     let x: i32;
                      ^
```

Rust предупредит нас о том, что мы никогда не используем связанную переменную,
но от того, что мы её не используем, не будет никакого вреда, поэтому нарушения
в этом нет. Однако, всё изменится, если мы попробуем использовать `x`. Сделаем
это. Измените вашу программу так, что бы она выглядела следующим образом:

```rust,ignore
fn main() {
    let x: i32;

    println!("x имеет значение {}", x);
}
```

И попробуйте собрать проект. Вы получите ошибку:

```bash
$ cargo build
   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
src/main.rs:4     println!("x имеет значение {}", x);
                                                    ^
note: in expansion of format_args!
<std macros>:2:23: 2:77 note: expansion site
<std macros>:1:1: 3:2 note: in expansion of println!
src/main.rs:4:5: 4:42 note: expansion site
error: aborting due to previous error
Could not compile `hello_world`.
```

Rust не позволит использовать неинициализированную переменную. Далее, поговорим
о `{}`, которые мы добавили в `println!`.

Если вы добавите две фигурные скобки (`{}`, иногда называемые "усами"...) в вашу
печатаемую строку, Rust истолкует это как просьбу вставки некоторого значения.
*Строковая интерполяция* - это термин в информатике, который обозначает
"вставить посреди строки". Мы добавили запятую, и затем `x`, что бы указать, что
мы хотим вставить `x` в строку. Запятая используется для разделения параметров,
если в функцию или макрос передаётся больше одного параметра.

При вставке переменной в строку, Rust проверит её тип и попытается отобразить
осмысленное значение. Если вы хотите указать формат более детально, то можете
ознакомиться с [доступными опциями форматирования строк (англ.)][format]. На данный
момент мы будем вставлять как есть: целые числа не очень сложны для печати.

[format]: http://doc.rust-lang.org/nightly/std/fmt/
