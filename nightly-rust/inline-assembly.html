<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Inline Assembly</title>

    <link rel="stylesheet" type="text/css" href="../rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='../INTRODUCTION.html'><b>2.</b> Введение</a>
</li>
<li><a href='../getting-started.html'><b>3.</b> C чего начать</a>
<ul class='section'>
<li><a href='../getting-started/installing-rust.html'><b>3.1.</b> Установка Rust</a>
</li>
<li><a href='../getting-started/hello-world.html'><b>3.2.</b> Hello, world!</a>
</li>
<li><a href='../getting-started/hello-cargo.html'><b>3.3.</b> Hello, Cargo!</a>
</li>
</ul>
</li>
<li><a href='../learn-rust.html'><b>4.</b> Изучение Rust</a>
<ul class='section'>
<li><a href='../learn-rust/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
</ul>
</li>
<li><a href='../effective-rust.html'><b>5.</b> Эффективное использование Rust</a>
<ul class='section'>
<li><a href='../effective-rust/the-stack-and-the-heap.html'><b>5.1.</b> Стек и Куча</a>
</li>
<li><a href='../effective-rust/testing.html'><b>5.2.</b> Тестирование</a>
</li>
<li><a href='../effective-rust/conditional-compilation.html'><b>5.3.</b> Условная компиляция</a>
</li>
<li><a href='../effective-rust/documentation.html'><b>5.4.</b> Документация</a>
</li>
<li><a href='../effective-rust/iterators.html'><b>5.5.</b> Итераторы</a>
</li>
<li><a href='../effective-rust/concurrency.html'><b>5.6.</b> Многозадачность</a>
</li>
<li><a href='../effective-rust/error-handling.html'><b>5.7.</b> Обработка ошибок</a>
</li>
<li><a href='../effective-rust/ffi.html'><b>5.8.</b> Интерфейс внешних функций (FFI)</a>
</li>
<li><a href='../effective-rust/release-channels.html'><b>5.9.</b> Каналы сборок</a>
</li>
</ul>
</li>
<li><a href='../syntax-and-semantics.html'><b>6.</b> Синтаксис и семантика</a>
<ul class='section'>
<li><a href='../syntax-and-semantics/variable-bindings.html'><b>6.1.</b> Связывание переменных</a>
</li>
<li><a href='../syntax-and-semantics/functions.html'><b>6.2.</b> Функции</a>
</li>
<li><a href='../syntax-and-semantics/primitive-types.html'><b>6.3.</b> Простые типы</a>
</li>
<li><a href='../syntax-and-semantics/comments.html'><b>6.4.</b> Комментарии</a>
</li>
<li><a href='../syntax-and-semantics/if.html'><b>6.5.</b> Конструкция `if`</a>
</li>
<li><a href='../syntax-and-semantics/for-loops.html'><b>6.6.</b> Циклы `for`</a>
</li>
<li><a href='../syntax-and-semantics/while-loops.html'><b>6.7.</b> Циклы `while`</a>
</li>
<li><a href='../syntax-and-semantics/ownership.html'><b>6.8.</b> Владение</a>
</li>
<li><a href='../syntax-and-semantics/references-and-borrowing.html'><b>6.9.</b> Ссылки и Заимствование</a>
</li>
<li><a href='../syntax-and-semantics/lifetimes.html'><b>6.10.</b> Время жизни</a>
</li>
<li><a href='../syntax-and-semantics/mutability.html'><b>6.11.</b> Изменяемость (Мутабельность)</a>
</li>
<li><a href='../syntax-and-semantics/enums.html'><b>6.12.</b> Перечисления</a>
</li>
<li><a href='../syntax-and-semantics/match.html'><b>6.13.</b> Конструкция `match`</a>
</li>
<li><a href='../syntax-and-semantics/structs.html'><b>6.14.</b> Структуры</a>
</li>
<li><a href='../syntax-and-semantics/patterns.html'><b>6.15.</b> Шаблоны `match`</a>
</li>
<li><a href='../syntax-and-semantics/method-syntax.html'><b>6.16.</b> Синтаксис методов</a>
</li>
<li><a href='../syntax-and-semantics/vectors.html'><b>6.17.</b> Вектора</a>
</li>
<li><a href='../syntax-and-semantics/strings.html'><b>6.18.</b> Строки</a>
</li>
<li><a href='../syntax-and-semantics/generics.html'><b>6.19.</b> Дженерики</a>
</li>
<li><a href='../syntax-and-semantics/traits.html'><b>6.20.</b> Трейты</a>
</li>
<li><a href='../syntax-and-semantics/drop.html'><b>6.21.</b> Трейт `Drop`</a>
</li>
<li><a href='../syntax-and-semantics/if-let.html'><b>6.22.</b> Конструкция `if let`</a>
</li>
<li><a href='../syntax-and-semantics/trait-objects.html'><b>6.23.</b> Трейт объекты</a>
</li>
<li><a href='../syntax-and-semantics/closures.html'><b>6.24.</b> Замыкания</a>
</li>
<li><a href='../syntax-and-semantics/ufcs.html'><b>6.25.</b> Универсальный синтаксис вызова функций (UFCS)</a>
</li>
<li><a href='../syntax-and-semantics/crates-and-modules.html'><b>6.26.</b> Контейнеры и Модули</a>
</li>
<li><a href='../syntax-and-semantics/const-and-static.html'><b>6.27.</b> `const` и `static`</a>
</li>
<li><a href='../syntax-and-semantics/tuple-structs.html'><b>6.28.</b> Кортежные структуры</a>
</li>
<li><a href='../syntax-and-semantics/attributes.html'><b>6.29.</b> Атрибуты</a>
</li>
<li><a href='../syntax-and-semantics/type-aliases.html'><b>6.30.</b> Псевдонимы типов</a>
</li>
<li><a href='../syntax-and-semantics/casting-between-types.html'><b>6.31.</b> Преобразование типов</a>
</li>
<li><a href='../syntax-and-semantics/associated-types.html'><b>6.32.</b> Ассоциированные типы</a>
</li>
<li><a href='../syntax-and-semantics/unsized-types.html'><b>6.33.</b> Безразмерные типы</a>
</li>
<li><a href='../syntax-and-semantics/operators-and-overloading.html'><b>6.34.</b> Operators and Overloading</a>
</li>
<li><a href='../syntax-and-semantics/deref-coercions.html'><b>6.35.</b> Трейт `Deref`</a>
</li>
<li><a href='../syntax-and-semantics/macros.html'><b>6.36.</b> Макросы</a>
</li>
<li><a href='../syntax-and-semantics/raw-pointers.html'><b>6.37.</b> Сырые указатели</a>
</li>
<li><a href='../syntax-and-semantics/unsafe.html'><b>6.38.</b> `unsafe` код</a>
</li>
</ul>
</li>
<li><a href='../nightly-rust.html'><b>7.</b> Нестабильные фичи Rust</a>
<ul class='section'>
<li><a href='../nightly-rust/compiler-plugins.html'><b>7.1.</b> Плагины компилятора</a>
</li>
<li><a href='../nightly-rust/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a href='../nightly-rust/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a href='../nightly-rust/intrinsics.html'><b>7.4.</b> Внутренние средства</a>
</li>
<li><a href='../nightly-rust/lang-items.html'><b>7.5.</b> Lang items</a>
</li>
<li><a href='../nightly-rust/link-args.html'><b>7.6.</b> Аргументы линковки</a>
</li>
<li><a href='../nightly-rust/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a href='../nightly-rust/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a href='../nightly-rust/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a href='../nightly-rust/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
</ul>
</li>
<li><a href='../glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a href='../academic-research.html'><b>9.</b> Академические исследования</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Inline Assembly</h1>
    <p>For extremely low-level manipulations and performance reasons, one
might wish to control the CPU directly. Rust supports using inline
assembly to do this via the <code>asm!</code> macro. The syntax roughly matches
that of GCC &amp; Clang:</p>
<span class='rusttest'>fn main() {
    asm!(assembly template
       : output operands
       : input operands
       : clobbers
       : options
       );
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='macro'>asm</span><span class='macro'>!</span>(<span class='ident'>assembly</span> <span class='ident'>template</span>
   : <span class='ident'>output</span> <span class='ident'>operands</span>
   : <span class='ident'>input</span> <span class='ident'>operands</span>
   : <span class='ident'>clobbers</span>
   : <span class='ident'>options</span>
   );
</pre>

<p>Any use of <code>asm</code> is feature gated (requires <code>#![feature(asm)]</code> on the
crate to allow) and of course requires an <code>unsafe</code> block.</p>

<blockquote>
<p><strong>Note</strong>: the examples here are given in x86/x86-64 assembly, but
all platforms are supported.</p>
</blockquote>

<h2 id="assembly-template" class='section-header'><a
                           href="#assembly-template">Assembly template</a></h2>
<p>The <code>assembly template</code> is the only required parameter and must be a
literal string (i.e. <code>&quot;&quot;</code>)</p>
<span class='rusttest'>#![feature(asm)]

#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn foo() {
    unsafe {
        asm!(&quot;NOP&quot;);
    }
}

// other platforms
#[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
fn foo() { /* ... */ }

fn main() {
    // ...
    foo();
    // ...
}
</span><pre id='rust-example-rendered' class='rust '>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>asm</span>)]</span>

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>any</span>(<span class='ident'>target_arch</span> <span class='op'>=</span> <span class='string'>&quot;x86&quot;</span>, <span class='ident'>target_arch</span> <span class='op'>=</span> <span class='string'>&quot;x86_64&quot;</span>))]</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>() {
    <span class='kw'>unsafe</span> {
        <span class='macro'>asm</span><span class='macro'>!</span>(<span class='string'>&quot;NOP&quot;</span>);
    }
}

<span class='comment'>// other platforms</span>
<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>not</span>(<span class='ident'>any</span>(<span class='ident'>target_arch</span> <span class='op'>=</span> <span class='string'>&quot;x86&quot;</span>, <span class='ident'>target_arch</span> <span class='op'>=</span> <span class='string'>&quot;x86_64&quot;</span>)))]</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>() { <span class='comment'>/* ... */</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// ...</span>
    <span class='ident'>foo</span>();
    <span class='comment'>// ...</span>
}
</pre>

<p>(The <code>feature(asm)</code> and <code>#[cfg]</code>s are omitted from now on.)</p>

<p>Output operands, input operands, clobbers and options are all optional
but you must add the right number of <code>:</code> if you skip them:</p>
<span class='rusttest'>#![feature(asm)]
#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn main() { unsafe {
asm!(&quot;xor %eax, %eax&quot;
    :
    :
    : &quot;eax&quot;
   );
} }
</span><pre id='rust-example-rendered' class='rust '>
<span class='macro'>asm</span><span class='macro'>!</span>(<span class='string'>&quot;xor %eax, %eax&quot;</span>
    :
    :
    : <span class='string'>&quot;eax&quot;</span>
   );
</pre>

<p>Whitespace also doesn&#39;t matter:</p>
<span class='rusttest'>#![feature(asm)]
#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn main() { unsafe {
asm!(&quot;xor %eax, %eax&quot; ::: &quot;eax&quot;);
} }
</span><pre id='rust-example-rendered' class='rust '>
<span class='macro'>asm</span><span class='macro'>!</span>(<span class='string'>&quot;xor %eax, %eax&quot;</span> ::: <span class='string'>&quot;eax&quot;</span>);
</pre>

<h2 id="operands" class='section-header'><a
                           href="#operands">Operands</a></h2>
<p>Input and output operands follow the same format: <code>: &quot;constraints1&quot;(expr1), &quot;constraints2&quot;(expr2), ...&quot;</code>. Output operand
expressions must be mutable lvalues:</p>
<span class='rusttest'>#![feature(asm)]
#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn add(a: i32, b: i32) -&gt; i32 {
    let mut c = 0;
    unsafe {
        asm!(&quot;add $2, $0&quot;
             : &quot;=r&quot;(c)
             : &quot;0&quot;(a), &quot;r&quot;(b)
             );
    }
    c
}
#[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
fn add(a: i32, b: i32) -&gt; i32 { a + b }

fn main() {
    assert_eq!(add(3, 14159), 14162)
}
</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>add</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>, <span class='ident'>b</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='number'>0</span>;
    <span class='kw'>unsafe</span> {
        <span class='macro'>asm</span><span class='macro'>!</span>(<span class='string'>&quot;add $2, $0&quot;</span>
             : <span class='string'>&quot;=r&quot;</span>(<span class='ident'>c</span>)
             : <span class='string'>&quot;0&quot;</span>(<span class='ident'>a</span>), <span class='string'>&quot;r&quot;</span>(<span class='ident'>b</span>)
             );
    }
    <span class='ident'>c</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>add</span>(<span class='number'>3</span>, <span class='number'>14159</span>), <span class='number'>14162</span>)
}
</pre>

<h2 id="clobbers" class='section-header'><a
                           href="#clobbers">Clobbers</a></h2>
<p>Some instructions modify registers which might otherwise have held
different values so we use the clobbers list to indicate to the
compiler not to assume any values loaded into those registers will
stay valid.</p>
<span class='rusttest'>#![feature(asm)]
#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn main() { unsafe {
// Put the value 0x200 in eax
asm!(&quot;mov $$0x200, %eax&quot; : /* no outputs */ : /* no inputs */ : &quot;eax&quot;);
} }
</span><pre id='rust-example-rendered' class='rust '>
<span class='comment'>// Put the value 0x200 in eax</span>
<span class='macro'>asm</span><span class='macro'>!</span>(<span class='string'>&quot;mov $$0x200, %eax&quot;</span> : <span class='comment'>/* no outputs */</span> : <span class='comment'>/* no inputs */</span> : <span class='string'>&quot;eax&quot;</span>);
</pre>

<p>Input and output registers need not be listed since that information
is already communicated by the given constraints. Otherwise, any other
registers used either implicitly or explicitly should be listed.</p>

<p>If the assembly changes the condition code register <code>cc</code> should be
specified as one of the clobbers. Similarly, if the assembly modifies
memory, <code>memory</code> should also be specified.</p>

<h2 id="options" class='section-header'><a
                           href="#options">Options</a></h2>
<p>The last section, <code>options</code> is specific to Rust. The format is comma
separated literal strings (i.e. <code>:&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</code>). It&#39;s used to
specify some extra info about the inline assembly:</p>

<p>Current valid options are:</p>

<ol>
<li><em>volatile</em> - specifying this is analogous to
<code>__asm__ __volatile__ (...)</code> in gcc/clang.</li>
<li><em>alignstack</em> - certain instructions expect the stack to be
aligned a certain way (i.e. SSE) and specifying this indicates to
the compiler to insert its usual stack alignment code</li>
<li><em>intel</em> - use intel syntax instead of the default AT&amp;T.</li>
</ol>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>