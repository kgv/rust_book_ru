<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Документация</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='basic.html'><b>2.</b> Основной уровень</a>
<ul class='section'>
<li><a href='installing-rust.html'><b>2.1.</b> Установка Rust</a>
</li>
<li><a href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
<li><a href='variable-bindings.html'><b>2.4.</b> Привязка переменных</a>
</li>
<li><a href='if.html'><b>2.5.</b> Условные переходы (If)</a>
</li>
<li><a href='functions.html'><b>2.6.</b> Функции</a>
</li>
<li><a href='comments.html'><b>2.7.</b> Коментарии</a>
</li>
<li><a href='compound-data-types.html'><b>2.8.</b> Составные типы данных</a>
</li>
<li><a href='match.html'><b>2.9.</b> Сопоставление с шаблоном (Match)</a>
</li>
<li><a href='looping.html'><b>2.10.</b> Циклы</a>
</li>
<li><a href='strings.html'><b>2.11.</b> Строки</a>
</li>
<li><a href='arrays-vectors-and-slices.html'><b>2.12.</b> Массивы, Вектора, Слайсы/Срезы</a>
</li>
<li><a href='standard-input.html'><b>2.13.</b> Стандартный ввод/вывод</a>
</li>
</ul>
</li>
<li><a href='intermediate.html'><b>3.</b> Средний уровень</a>
<ul class='section'>
<li><a href='crates-and-modules.html'><b>3.1.</b> Крейты и Модули</a>
</li>
<li><a href='testing.html'><b>3.2.</b> Тестирование</a>
</li>
<li><a href='pointers.html'><b>3.3.</b> Указатели</a>
</li>
<li><a href='ownership.html'><b>3.4.</b> Владение</a>
</li>
<li><a href='more-strings.html'><b>3.5.</b> Больше о строках</a>
</li>
<li><a href='patterns.html'><b>3.6.</b> Шаблоны</a>
</li>
<li><a href='method-syntax.html'><b>3.7.</b> Синтаксис методов</a>
</li>
<li><a href='closures.html'><b>3.8.</b> Замыкания</a>
</li>
<li><a href='iterators.html'><b>3.9.</b> Итераторы</a>
</li>
<li><a href='generics.html'><b>3.10.</b> Дженерики</a>
</li>
<li><a href='traits.html'><b>3.11.</b> Трейты</a>
</li>
<li><a href='static-and-dynamic-dispatch.html'><b>3.12.</b> Статическая и Динамическая диспетчерезация</a>
</li>
<li><a href='macros.html'><b>3.13.</b> Макросы</a>
</li>
<li><a href='concurrency.html'><b>3.14.</b> Concurrency</a>
</li>
<li><a href='error-handling.html'><b>3.15.</b> Обработка ошибок</a>
</li>
<li><a href='documentation.html'><b>3.16.</b> Документация</a>
</li>
</ul>
</li>
<li><a href='advanced.html'><b>4.</b> Продвинутый уровень</a>
<ul class='section'>
<li><a href='ffi.html'><b>4.1.</b> FFI</a>
</li>
<li><a href='unsafe.html'><b>4.2.</b> Небезопасный код</a>
</li>
<li><a href='advanced-macros.html'><b>4.3.</b> Продвинутые макросы</a>
</li>
<li><a href='plugins.html'><b>4.4.</b> Плагины компилятора</a>
</li>
</ul>
</li>
<li><a href='conclusion.html'><b>5.</b> Заключение</a>
</li>
<li><a href='glossary.html'><b>6.</b> Глоссарий</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Документация</h1>
    <p>Документация является важной частью любого программного проекта, и она первоклассная в Rust. Давайте поговорим об инструментах Rust, предназначенных для создания документации к проекту.</p>

<h2 id="О-rustdoc" class='section-header'><a
                           href="#О-rustdoc">О <code>rustdoc</code></a></h2>
<p>Дистрибутив Rust включает в себя инструмент, <code>rustdoc</code>, который генерирует документацию. <code>rustdoc</code> также используется Cargo через <code>cargo doc</code>.</p>

<p>Документация может быть сгенерирована двумя методами: из исходного кода, и из автономных Markdown файлов.</p>

<h2 id="Документирование-исходного-кода" class='section-header'><a
                           href="#Документирование-исходного-кода">Документирование исходного кода</a></h2>
<p>Основной способ документирования проекта на Rust заключается в комментировании исходного кода. Для этой цели вы можете использовать комментарии документации:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// Constructs a new `Rc&lt;T&gt;`.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// # Examples</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// ```</span>
<span class='doccomment'>/// use std::rc::Rc;</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// let five = Rc::new(5);</span>
<span class='doccomment'>/// ```</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>value</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>Rc</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='comment'>// implementation goes here</span>
}
</pre>

<p>Этот код генерирует документацию, которая выглядит <a href="http://doc.rust-lang.org/nightly/std/rc/struct.Rc.html#method.new">так</a>. В приведенном коде реализация метода была заменена на обычный комментарий. Первое, на что следует обратить внимание в этом примере: используется <code>///</code>, а не <code>//</code>. Тройной символ <code>/</code> указывает, что это комментарий документации.</p>

<p>Комментарии документации написаны на Markdown.</p>

<p>Rust отслеживает такие комментарии, и использует их при генерировании документации. Что важно при документировании таких вещей, как перечисления:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// The `Option` type. See [the module level documentation](../) for more.</span>
<span class='kw'>enum</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='doccomment'>/// No value</span>
    <span class='prelude-val'>None</span>,
    <span class='doccomment'>/// Some value `T`</span>
    <span class='prelude-val'>Some</span>(<span class='ident'>T</span>),
}
</pre>

<p>Код, приведенный выше работает, а ниже - не работает:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// The `Option` type. See [the module level documentation](../) for more.</span>
<span class='kw'>enum</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='prelude-val'>None</span>, <span class='doccomment'>/// No value</span>
    <span class='prelude-val'>Some</span>(<span class='ident'>T</span>), <span class='doccomment'>/// Some value `T`</span>
}
</pre>

<p>Вы получите ошибку:</p>

<pre><code class="language-text">hello.rs:4:1: 4:2 error: expected ident, found `}`
hello.rs:4 }
           ^
</code></pre>

<p>Эта досадная <a href="https://github.com/rust-lang/rust/issues/22547">ошибка</a> заключается в следующем: комментарии документации распространяются на элементы, расположенные за ними, а в данном примере нет элемента, расположенного после последнего комментария.</p>

<h3 id="Написание-комментариев-документации" class='section-header'><a
                           href="#Написание-комментариев-документации">Написание комментариев документации</a></h3>
<p>Давайте рассмотрим каждую часть приведенного комментария в деталях:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// Constructs a new `Rc&lt;T&gt;`.</span>
</pre>

<p>Первая строка комментария документации должна представлять из себя краткую информацию о функциональности. Одно предложение. Только самое основное. Высокоуровневое.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>///</span>
<span class='doccomment'>/// Other details about constructing `Rc&lt;T&gt;`s, maybe describing complicated</span>
<span class='doccomment'>/// semantics, maybe additional options, all kinds of stuff.</span>
<span class='doccomment'>///</span>
</pre>

<p>Наш исходный пример включал только строку с краткой информацией, но если бы у нас было больше информации, о которой следует сказать, мы могли бы добавить эту информацию в новом параграфе.</p>

<h4 id="Специальные-разделы" class='section-header'><a
                           href="#Специальные-разделы">Специальные разделы</a></h4><pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// # Examples</span>
</pre>

<p>Далее идут специальные разделы. Они обозначены с заголовком, который начинается с <code>#</code>. Существуют три вида заголовков, которые обычно используются. Они не являются каким-либо специальным синтаксисом, на данный момент это просто соглашение.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// # Panics</span>
</pre>

<p>Невыявляемые случаи неправильного использования функции (так называемые ошибки программирования) в Rust как правило вызывают панику, которая, в крайнем случае, убивает весь текущий поток (thread). Если ваша функция имеет нетривиальный контракт (поведение), другими словами, обнаруживает/создает панику, то очень важно задокументировать это.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// # Failures</span>
</pre>

<p>Если ваша функция или метод возвращает <code>Result&lt;T, E&gt;</code>, то было бы правильно описать условия, при которых она возвращает <code>Err(E)</code>. Это чуть менее важно, чем описание <code>Panics</code>, потому как неудача кодируется в системе типа, но это не значит что стоит пренебрегать этим.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// # Safety</span>
</pre>

<p>Если ваша функция является <code>unsafe</code>, необходимо пояснить, какие инварианты вызова должны поддерживаться.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// # Examples</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// ```</span>
<span class='doccomment'>/// use std::rc::Rc;</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// let five = Rc::new(5);</span>
<span class='doccomment'>/// ```</span>
</pre>

<p>Раздел <code>Examples</code>. Включите в этот раздел один или несколько примеров использования функции или метода, и ваши пользователи будут вам благодарны за это. Примеры должны размещаться внутри блока кода, о чем мы сейчас и будем говорить, и могут иметь более одного раздела:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// # Examples</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// Simple `&amp;str` patterns:</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// ```</span>
<span class='doccomment'>/// let v: Vec&lt;&amp;str&gt; = &quot;Mary had a little lamb&quot;.split(&#39; &#39;).collect();</span>
<span class='doccomment'>/// assert_eq!(v, vec![&quot;Mary&quot;, &quot;had&quot;, &quot;a&quot;, &quot;little&quot;, &quot;lamb&quot;]);</span>
<span class='doccomment'>/// ```</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// More complex patterns with a lambda:</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// ```</span>
<span class='doccomment'>/// let v: Vec&lt;&amp;str&gt; = &quot;abc1def2ghi&quot;.split(|c: char| c.is_numeric()).collect();</span>
<span class='doccomment'>/// assert_eq!(v, vec![&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]);</span>
<span class='doccomment'>/// ```</span>
</pre>

<p>Давайте детально обсудим блоки кода.</p>

<h4 id="Блок-кода" class='section-header'><a
                           href="#Блок-кода">Блок кода</a></h4>
<p>Чтобы написать код на Rust в комментарии, используйте символы ```:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// ```</span>
<span class='doccomment'>/// println!(&quot;Hello, world&quot;);</span>
<span class='doccomment'>/// ```</span>
</pre>

<p>Если вы хотите написать код на любом другом языке (не на Rust), вы можете добавить аннотацию:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// ```c</span>
<span class='doccomment'>/// printf(&quot;Hello, world\n&quot;);</span>
<span class='doccomment'>/// ```</span>
</pre>

<p>Это позволит использовать подсветку синтаксиса, соответствующую тому языку, который был указан в аннотации. Если же это простой текст, то в аннотации указывается <code>text</code>.</p>

<p>Важно выбрать правильную аннотацию, потому что <code>rustdoc</code> использует ее интересным способом: Rust может выполнять проверку работоспособности примеров на момент запуска, чтобы они не устаревали. Предположим у вас есть код на C. Если вы опустите аннотацию, указывающую, что это код на C, то <code>rustdoc</code> будет думать, что это код на Rust, поэтому <code>rustdoc</code> будет жаловаться при попытке создания документации.</p>

<h2 id="Тесты-в-документации" class='section-header'><a
                           href="#Тесты-в-документации">Тесты в документации</a></h2>
<p>Давайте обсудим наш пример документации:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// ```</span>
<span class='doccomment'>/// println!(&quot;Hello, world&quot;);</span>
<span class='doccomment'>/// ```</span>
</pre>

<p>Заметьте, что здесь нет нужды в <code>fn main()</code> или чем-нибудь подобном. <code>rustdoc</code> автоматически добавит main() обертку вокруг вашего кода в нужном месте. Например:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// ```</span>
<span class='doccomment'>/// use std::rc::Rc;</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// let five = Rc::new(5);</span>
<span class='doccomment'>/// ```</span>
</pre>

<p>В конечном итоге это будет тест:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rc</span>::<span class='ident'>Rc</span>;
    <span class='kw'>let</span> <span class='ident'>five</span> <span class='op'>=</span> <span class='ident'>Rc</span>::<span class='ident'>new</span>(<span class='number'>5</span>);
}
</pre>

<p>Вот полный алгоритм, который использует <code>rustdoc</code> для постобработки примеров:</p>

<ol>
<li>Любые ведущие (leading) атрибуты <code>#![foo]</code> остаются без изменений в качестве атрибутов крейта.</li>
<li>Будут вставлены некоторые общие <code>allow</code> атрибуты, в том числе: <code>unused_variables</code>, <code>unused_assignments</code>, <code>unused_mut</code>, <code>unused_attributes</code>, <code>dead_code</code>. Небольшие примеры часто вызывают эти lints.</li>
<li>Если пример не содержит <code>extern crate</code>, то будет вставлено <code>extern crate &lt;mycrate&gt;;</code>.</li>
<li>Наконец, если пример не содержит <code>fn main</code>, то оставшаяся часть текста будет обернута в <code>fn main() { your_code }</code></li>
</ol>

<p>Хотя иногда этого не достаточно. Например, все эти примеры кода с <code>///</code> мы говорим о? Ниже представлен блок кода до обработки <code>rustdoc</code>, в виде простого текста:</p>

<p>Sometimes, this isn&#39;t enough, though. For example, all of these code samples
with <code>///</code> we&#39;ve been talking about? The raw text:</p>

<pre><code class="language-text">/// Some documentation.
# fn foo() {}
</code></pre>

<p>и после обработки <code>rustdoc</code>, в виде вывода:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// Some documentation.</span>
</pre>

<p>Выглядят они по-разному.</p>

<p>Да, именно так: вы можете добавлять строки, которые начинаются с <code>#</code>, и они будут скрыты в выводе, но при этом будут использоваться во время компиляции кода. Вы можете использовать это в своих интересах. Если в комментарии документации необходимо обратиться к какой-то функции, то ниже нужно будет добавить определение этой функции. В то же время, это делается только для того, чтобы удовлетворить компилятор, поэтому сокрытие ненужных строк в выводе делает пример более ясным. Вы можете использовать эту технику, чтобы детально объяснять длинные примеры, сохраняя при этом тестируемость документации. Например, этот код:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>6</span>;
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>y</span>);
</pre>

<p>Вот объяснение, которое будет сгенерировано:</p>

<p>Сперва мы устанавливаем <code>x</code> равным пяти:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
</pre>

<p>Затем мы устанавливаем <code>y</code> равным шести:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>6</span>;
</pre>

<p>В конце мы печатаем сумму <code>x</code> и <code>y</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>y</span>);
</pre>

<p>Вот то же самое объяснение, но в виде простого текста:</p>

<blockquote>
<p>Сперва мы устанавливаем <code>x</code> равным пяти:</p>

<pre><code class="language-text">let x = 5;
# let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>

<p>Затем мы устанавливаем <code>y</code> равным шести:</p>

<pre><code class="language-text"># let x = 5;
let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>

<p>В конце мы печатаем сумму <code>x</code> и <code>y</code>:</p>

<pre><code class="language-text"># let x = 5;
# let y = 6;
println!(&quot;{}&quot;, x + y);
</code></pre>
</blockquote>

<p>Повторяя все части примера, вы можете быть уверены, что ваш пример компилируется, а не просто отображает кусоки кода, которые имеют отношение к той или иной части вашего объяснения.</p>

<h3 id="Документирование-макросов" class='section-header'><a
                           href="#Документирование-макросов">Документирование макросов</a></h3>
<p>Вот пример документирования макроса:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// Panic with a given message unless an expression evaluates to true.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// # Examples</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// ```</span>
<span class='doccomment'>/// # #[macro_use] extern crate foo;</span>
<span class='doccomment'>/// # fn main() {</span>
<span class='doccomment'>/// panic_unless!(1 + 1 == 2, “Math is broken.”);</span>
<span class='doccomment'>/// # }</span>
<span class='doccomment'>/// ```</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// ```should_fail</span>
<span class='doccomment'>/// # #[macro_use] extern crate foo;</span>
<span class='doccomment'>/// # fn main() {</span>
<span class='doccomment'>/// panic_unless!(true == false, “I’m broken.”);</span>
<span class='doccomment'>/// # }</span>
<span class='doccomment'>/// ```</span>
<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>panic_unless</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>condition</span>:<span class='ident'>expr</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>:<span class='ident'>expr</span>),<span class='op'>+</span>) <span class='op'>=&gt;</span> ({ <span class='kw'>if</span> <span class='op'>!</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>condition</span> { <span class='macro'>panic</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>),<span class='op'>+</span>); } });
}
</pre>

<p>В нем вы можете заметить, три вещи. Во-первых, мы должны собственноручно добавить строку с <code>extern crate</code>, для того, чтобы мы могли указать атрибут <code>#[macro_use]</code>. Во-вторых, мы также собственноручно должны добавить <code>main()</code>. И наконец, разумно будет использовать <code>#</code>, чтобы закомментировать все, что мы добавили в первых двух пунктах, что бы оно не отображалось в вводе.</p>

<h3 id="Запуск-тестов-в-документации" class='section-header'><a
                           href="#Запуск-тестов-в-документации">Запуск тестов в документации</a></h3>
<p>Для запуска тестов можно использовать одну из двух комманд</p>

<pre><code class="language-bash">$ rustdoc --test path/to/my/crate/root.rs
# or
$ cargo test
</code></pre>

<p>Все верно, <code>cargo test</code> также выполняет тесты, встроенные в документацию.</p>

<p>Есть еще несколько аннотаций, которые являются полезными, помогающих <code>rustdoc</code> работать правильно (корректно) при тестировании код:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// ```ignore</span>
<span class='doccomment'>/// fn foo() {</span>
<span class='doccomment'>/// ```</span>
</pre>

<p>Директива <code>ignore</code> указывает Rust, что код должен быть проигнорирован. Почти во всех случаях это не то, что вам нужно, так как эта директива носит очень общий характер. Вместо нее лучше использовать аннотацию <code>text</code>, если это не код, или <code>#</code>, чтобы получить рабочий пример, отображающий только ту часть, которая вам нужна.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// ```should_panic</span>
<span class='doccomment'>/// assert!(false);</span>
<span class='doccomment'>/// ```</span>
</pre>

<p>Аннотация <code>should_panic</code> указывает <code>rustdoc</code>, что код должен компилироваться, но выполнение теста должно завершиться ошибкой.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// ```no_run</span>
<span class='doccomment'>/// loop {</span>
<span class='doccomment'>///     println!(&quot;Hello, world&quot;);</span>
<span class='doccomment'>/// }</span>
<span class='doccomment'>/// ```</span>
</pre>

<p>Атрибут <code>no_run</code> указывает, что что код должен компилироваться, но запускать его на выполнение не требуется. Это важно для таких примеров, которые должны успешно компилироваться, но которые выполняются в бесконечном цикле! Например: &quot;Вот как запустить сетевой сервис&quot;.</p>

<h3 id="Документирование-модулей" class='section-header'><a
                           href="#Документирование-модулей">Документирование модулей</a></h3>
<p>Rust предоставляет еще один вид комментариев документации, <code>//!</code>. Этот комментарий относится не к следующему за ним элементу, а к элементу, который его включает. Другими словами:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='doccomment'>//! This is documentation for the `foo` module.</span>
    <span class='doccomment'>//!</span>
    <span class='doccomment'>//! # Examples</span>

    <span class='comment'>// ...</span>
}
</pre>

<p>Приведенный пример демонстрирует наиболее распространенное использование <code>//!</code>: документирование модуля. Если же модуль расположен в файле <code>foo.rs</code>, то вы часто будете открывать его код и видеть это:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>//! A module for using `foo`s.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! The `foo` module contains a lot of useful functionality blah blah blah</span>
</pre>

<h3 id="Стиль-комментариев-документации" class='section-header'><a
                           href="#Стиль-комментариев-документации">Стиль комментариев документации</a></h3>
<p>Изучите <a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505</a> для получения полных сведений о соглашениях по стилю и формату документации.</p>

<h2 id="Другая-документация" class='section-header'><a
                           href="#Другая-документация">Другая документация</a></h2>
<p>Все эти правила поведения также применимы и в отношении исходных файлов не на Rust. Так как комментарии пишутся на Markdown, то часто эти файлы имеют расширение <code>.md</code>.</p>

<p>Когда вы пишете документацию в Markdown файлах, вам не нужно добавлять префикс комментария документации, <code>///</code>. Например:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// # Examples</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// ```</span>
<span class='doccomment'>/// use std::rc::Rc;</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// let five = Rc::new(5);</span>
<span class='doccomment'>/// ```</span>
</pre>

<p>преобразуется в</p>

<pre><code class="language-markdown"># Examples

```
use std::rc::Rc;

let five = Rc::new(5);
```
</code></pre>

<p>когда он находится в Markdown файле. Однако есть один недостаток: Markdown файлы должны иметь заголовок наподобие этого:</p>

<pre><code class="language-markdown">% The title

This is the example documentation.
</code></pre>

<p>Строка, начинающаяся с <code>%</code>, должна быть самой первой строкой файла.</p>

<h2 id="Атрибуты-doc" class='section-header'><a
                           href="#Атрибуты-doc">Атрибуты <code>doc</code></a></h2>
<p>На более глубоком уровне, комментарии документации - это синтаксический сахар для атрибутов документации:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// this</span>

<span class='attribute'>#[<span class='ident'>doc</span><span class='op'>=</span><span class='string'>&quot;this&quot;</span>]</span>
</pre>

<p>такие же, как и эти:</p>

<p>are the same, as are these:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>//! this</span>

<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>doc</span><span class='op'>=</span><span class='string'>&quot;/// this&quot;</span>]</span>
</pre>

<p>Вы не часто будете видеть этот атрибут, используемый для написания документации, но он может быть полезен, когда изменения некоторых настроек, или при написании макроса.</p>

<h3 id="Ре-экспорт" class='section-header'><a
                           href="#Ре-экспорт">Ре-экспорт</a></h3>
<p><code>rustdoc</code> будет показывать документацию для publc реэкспорта в обоих местах:</p>

<p><code>rustdoc</code> will show the documentation for a publc re-export in both places:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>foo</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>bar</span>;
</pre>

<p>Это создаст документацию для <code>bar</code> как в документации для крейта <code>foo</code>, так и в документации к вашему крейту. Так что будет использована одна и та же документация в обоих местах.</p>

<p>Такое поведение может быть подавлено с помощью <code>no_inline</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>foo</span>;

<span class='attribute'>#[<span class='ident'>doc</span>(<span class='ident'>no_inline</span>)]</span>
<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>bar</span>;
</pre>

<h3 id="Управление-html" class='section-header'><a
                           href="#Управление-html">Управление HTML</a></h3>
<p>Вы можете управлять некоторыми аспектами HTML, который генерируется <code>rustdoc</code>, через атрибут <code>#![doc]</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>doc</span>(<span class='ident'>html_logo_url</span> <span class='op'>=</span> <span class='string'>&quot;http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png&quot;</span>,
       <span class='ident'>html_favicon_url</span> <span class='op'>=</span> <span class='string'>&quot;http://www.rust-lang.org/favicon.ico&quot;</span>,
       <span class='ident'>html_root_url</span> <span class='op'>=</span> <span class='string'>&quot;http://doc.rust-lang.org/&quot;</span>)]</span>;
</pre>

<p>В этом примере устанавливается несколько различных опций: логотип, иконка и корневой URL.</p>

<h2 id="Опции-генерации" class='section-header'><a
                           href="#Опции-генерации">Опции генерации</a></h2>
<p><code>rustdoc</code> также содержит несколько опций командной строки, для дальнейшей кастомизации:</p>

<ul>
<li><code>--html-in-header FILE</code>: включить содержание FILE в конце <code>&lt;head&gt;...&lt;/head&gt;</code> раздела.</li>
<li><code>--html-before-content FILE</code>: включить содержание FILE сразу после <code>&lt;body&gt;</code>, перед отображаемым содержимым (в том числе строки поиска).</li>
<li><code>--html-after-content FILE</code>: включить содержание FILE после всего отображаемого содержимого.</li>
</ul>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceeding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
</div></div>


</body>
</html>