% Конструкция `match` (Сопоставление с шаблоном)

Простого `if`/`else` часто недостаточно, потому что нужно проверить больше, чем
два возможных варианта. Да и к тому же условия в `else` часто становятся очень
сложными. Как же решить эту проблему?

В Rust есть ключевое слово `match`, позволяющее заменить группы операторов
`if`/`else` чем-то более удобным. Смотрите:

```rust
let x = 5;

match x {
    1 => println!("один"),
    2 => println!("два"),
    3 => println!("три"),
    4 => println!("четыре"),
    5 => println!("пять"),
    _ => println!("что-то ещё"),
}
```

`match` принимает выражение и выбирает одну из ветвей исполнения согласно его
значению. Каждая *ветвь* имеет форму `значение => выражение`. Выражение ветви
вычисляется, когда значение данной ветви совпадает со значением, принятым
оператором `match` (в данном случае, `x`). Эта конструкция называется `match`
(сопоставление), потому что она выполняет сопоставление значения неким
"шаблонам". Раздел [Шаблоны][patterns], идущий далее, охватывает все варианты,
которые были затронуты здесь.

[patterns]: patterns.html

Так в чём же преимущества данной конструкции? Их несколько. Во-первых, ветви
`match` *проверяются на полноту*. Видите последнюю ветвь, со знаком
подчёркивания (`_`)? Если мы удалим её, Rust выдаст ошибку:

```text
error: non-exhaustive patterns: `_` not covered
```

Другими словами, компилятор сообщает нам, что мы забыли сопоставить какие-то
значения. Поскольку `x` - это целое число, оно может принимать разные значения -
например, `6`. Однако, если мы убираем ветвь `_`, ни одна ветвь не совпадёт,
поэтому такой код не скомпилируется. `_` - это ‘совпадение с любым значением‘.
Если ни одна другая ветвь не совпала, совпадёт ветвь с `_`. Поскольку в примере
выше есть ветвь с `_`, мы покрываем всё множество значений `x`, и наша программа
скомпилируется.

`match` также является выражением. Это значит, что мы можем использовать его в
правой части оператора `let` или непосредственно как выражение:

```rust
let x = 5;

let numer = match x {
    1 => "one",
    2 => "two",
    3 => "three",
    4 => "four",
    5 => "five",
    _ => "something else",
};
```

Иногда это очень удобный вариант преобразования.
