% –£–≥–∞–¥–∞–π–∫–∞

–í –∫–∞—á–µ—Å—Ç–≤–µ –Ω–∞—à–µ–≥–æ –ø–µ—Ä–≤–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞, –º—ã —Ä–µ—à–∏–º –∫–ª–∞—Å—Å–∏—á–µ—Å–∫—É—é –¥–ª—è –Ω–∞—á–∏–Ω–∞—é—â–∏—Ö 
–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–≤ –∑–∞–¥–∞—á—É: –∏–≥—Ä–∞-—É–≥–∞–¥–∞–π–∫–∞. –ù–µ–º–Ω–æ–≥–æ –æ —Ç–æ–º, –∫–∞–∫ –∏–≥—Ä–∞ –¥–æ–ª–∂–Ω–∞ —Ä–∞–±–æ—Ç–∞—Ç—å:
–Ω–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ª—É—á–∞–π–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –∏–∑ –ø—Ä–æ–º–µ–∂—É—Ç–∫–∞ –æ—Ç 1 –¥–æ 100. –ó–∞—Ç–µ–º
–æ–Ω–∞ –ø—Ä–æ—Å–∏—Ç –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ, –∫–æ—Ç–æ—Ä–æ–µ –æ–Ω–∞ "–∑–∞–≥–∞–¥–∞–ª–∞". –î–ª—è –∫–∞–∂–¥–æ–≥–æ –≤–≤–µ–¥—ë–Ω–Ω–æ–≥–æ –Ω–∞–º–∏ 
—á–∏—Å–ª–∞, –æ–Ω–∞ –≥–æ–≤–æ—Ä–∏—Ç, –±–æ–ª—å—à–µ –ª–∏ –æ–Ω–æ, —á–µ–º "–∑–∞–≥–∞–¥–∞–Ω–Ω–æ–µ", –∏–ª–∏ –º–µ–Ω—å—à–µ. –ò–≥—Ä–∞ 
–∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –∫–æ–≥–¥–∞ –º—ã –æ—Ç–≥–∞–¥—ã–≤–∞–µ–º —á–∏—Å–ª–æ. –ó–≤—É—á–∏—Ç –Ω–µ –ø–ª–æ—Ö–æ, –Ω–µ —Ç–∞–∫ –ª–∏?

# –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞

–î–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –≤–∞—à—É –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é —Å –ø—Ä–æ–µ–∫—Ç–∞–º–∏. –ü–æ–º–Ω–∏—Ç–µ,
–∫–∞–∫ –º—ã —Å–æ–∑–¥–∞–≤–∞–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π –∏ `Cargo.toml` –¥–ª—è `hello_world`? Cargo 
–º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ –∑–∞ –Ω–∞—Å. –î–∞–≤–∞–π—Ç–µ –≤–æ—Å–ø–æ–ª—å–∑—É–µ–º—Å—è —ç—Ç–∏–º:

```bash
$ cd ~/projects
$ cargo new guessing_game --bin
$ cd guessing_game
```

–ú—ã —Å–∫–∞–∑–∞–ª–∏ Cargo, —á—Ç–æ —Ö–æ—Ç–∏–º —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç —Å –∏–º–µ–Ω–µ–º `guessing_game`.–ü—Ä–∏ 
–ø–æ–º–æ—â–∏ —Ñ–ª–∞–≥–∞ `--bin`, –º—ã —É–∫–∞–∑–∞–ª–∏ —á—Ç–æ —Ö–æ—Ç–∏–º —Å–æ–∑–¥–∞—Ç—å –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª, –∞ –Ω–µ 
–±–∏–±–ª–∏–æ—Ç–µ–∫—É.

–î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π `Cargo.toml`:

```toml
[package]

name = "guessing_game"
version = "0.0.1"
authors = ["Your Name <you@example.com>"]
```

Cargo –≤–∑—è–ª —ç—Ç—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ –≤–∞—à–µ–≥–æ —Ä–∞–±–æ—á–µ–≥–æ –æ–∫—Ä—É–∂–µ–Ω–∏—è. –ï—Å–ª–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ 
–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞, –∏—Å–ø—Ä–∞–≤—å—Ç–µ –µ—ë.

–í –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ, Cargo —Å–æ–∑–¥–∞–ª –ø—Ä–æ–≥—Ä–∞–º–º—É `Hello, world!`. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ —Ñ–∞–π–ª `src/main.rs`:

```rust
fn main() {
    println!("Hello, world!")
}
```

–î–∞–≤–∞–π—Ç–µ –ø–æ–ø—Ä–æ–±—É–µ–º —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å —Å–æ–∑–¥–∞–Ω–Ω—ã–π Cargo –ø—Ä–æ–µ–∫—Ç:

```{bash}
$ cargo build
   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)
```

–ó–∞–º–µ—á–∞—Ç–µ–ª—å–Ω–æ! –°–Ω–æ–≤–∞ –æ—Ç–∫—Ä–æ–π—Ç–µ `src/main.rs`. –ú—ã –±—É–¥–µ–º –ø–∏—Å–∞—Ç—å –≤–µ—Å—å –Ω–∞—à –∫–æ–¥ –≤ —ç—Ç–æ–º
—Ñ–∞–π–ª–µ.

–ü—Ä–µ–∂–¥–µ, —á–µ–º –º—ã –Ω–∞—á–Ω—ë–º —Ä–∞–±–æ—Ç—É, –¥–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –µ—â—ë –æ–¥–Ω—É –∫–æ–º–∞–Ω–¥—É Cargo: `run`.
`cargo run` –ø–æ—Ö–æ–∂–∞ –Ω–∞ `cargo build`, –Ω–æ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –æ–Ω–∞ 
–∑–∞–ø—É—Å–∫–∞–µ—Ç –ø–æ–ª—É—á–∏–≤—à–∏–π—Å—è –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª:

```bash
$ cargo run
   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Hello, world!
```

–í–µ–ª–∏–∫–æ–ª–µ–ø–Ω–æ! –ö–æ–º–∞–Ω–¥–∞ `run` –ø–æ–º–æ–≥–∞–µ—Ç, –∫–æ–≥–¥–∞ –Ω–∞–¥–æ –±—ã—Å—Ç—Ä–æ –ø–µ—Ä–µ—Å–æ–±–∏—Ä–∞—Ç—å –ø—Ä–æ–µ–∫—Ç. –ù–∞—à–∞
–∏–≥—Ä–∞ –∫–∞–∫ —Ä–∞–∑ –∏ –µ—Å—Ç—å —Ç–∞–∫–æ–π –ø—Ä–æ–µ–∫—Ç: –Ω–∞–º –Ω–∞–¥–æ –±—ã—Å—Ç—Ä–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∂–¥–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ,
–ø—Ä–µ–∂–¥–µ —á–µ–º –º—ã –ø—Ä–∏—Å—Ç—É–ø–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–π —á–∞—Å—Ç–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã.

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏—è

–î–∞–≤–∞–π—Ç–µ –Ω–∞—á–Ω—ë–º! –ü–µ—Ä–≤–∞—è –≤–µ—â—å, –∫–æ—Ç–æ—Ä—É—é –º—ã –¥–æ–ª–∂–Ω—ã —Å–¥–µ–ª–∞—Ç—å –¥–ª—è –Ω–∞—à–µ–π –∏–≥—Ä—ã - —ç—Ç–æ 
–ø–æ–∑–≤–æ–ª–∏—Ç—å –∏–≥—Ä–æ–∫—É –≤–≤–æ–¥–∏—Ç—å –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏—è. –ü–æ–º–µ—Å—Ç–∏—Ç–µ —Å–ª–µ–¥—É—é—â–∏–π –∫–æ–¥ –≤ –≤–∞—à `src/main.rs`:

```rust,no_run
use std::io;

fn main() {
    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");

    println!("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏–µ.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .ok()
        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Å—Ç—Ä–æ–∫—É");

    println!("–í—ã –∑–∞–≥–∞–¥–∞–ª–∏: {}", guess);
}
```

–ó–¥–µ—Å—å –º–Ω–æ–≥–æ —á–µ–≥–æ! –î–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä—ë–º —ç—Ç–æ—Ç —É—á–∞—Å—Ç–æ–∫ –ø–æ —á–∞—Å—Ç—è–º.

```rust,ignore
use std::io;
```

–ù–∞–º –Ω–∞–¥–æ –ø–æ–ª—É—á–∏—Ç—å —Ç–æ, —á—Ç–æ –≤–≤—ë–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å, –∞ –∑–∞—Ç–µ–º –≤—ã–≤–µ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–∞ —ç–∫—Ä–∞–Ω.
–ó–Ω–∞—á–∏—Ç –Ω–∞–º –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ `io` –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏. –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ Rust 
–∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç –ª–∏—à—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≤–µ—â–∏ –≤ –Ω–∞—à—É –ø—Ä–æ–≥—Ä–∞–º–º—É, –≤ —Ç–∞–∫ –Ω–∞–∑—ã–≤–∞–µ–º–æ–º [`–≤—Å—Ç—É–ø–ª–µ–Ω–∏–∏`][prelude].
–ï—Å–ª–∏ —á–µ–≥–æ-—Ç–æ –Ω–µ—Ç –ø–æ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–∏, –º—ã –¥–æ–ª–∂–Ω—ã —É–∫–∞–∑–∞—Ç—å –ø—Ä–∏ –ø–æ–º–æ—â–∏ `use`, —á—Ç–æ —Ö–æ—Ç–∏–º –∏—Ö
–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å.

[prelude]: ../std/prelude/index.html

```rust,ignore
fn main() {
```

–ö–∞–∫ –≤—ã —É–∂–µ –≤–∏–¥–µ–ª–∏ –¥–æ —ç—Ç–æ–≥–æ, —Ñ—É–Ω–∫—Ü–∏—è `main()` - —ç—Ç–æ —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –≤ –Ω–∞—à—É –ø—Ä–æ–≥—Ä–∞–º–º—É.
`fn` –æ–±—ä—è–≤–ª—è–µ—Ç –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é. –ü—É—Å—Ç—ã–µ –∫—Ä—É–≥–ª—ã–µ —Å–∫–æ–±–∫–∏ `()` –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç, —á—Ç–æ –æ–Ω–∞ –Ω–µ
–ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤. –û—Ç–∫—Ä—ã–≤–∞—é—â–∞—è —Ñ–∏–≥—É—Ä–Ω–∞—è —Å–∫–æ–±–∫–∞ `{` –Ω–∞—á–∏–Ω–∞–µ—Ç —Ç–µ–ª–æ –Ω–∞—à–µ–π 
—Ñ—É–Ω–∫—Ü–∏–∏. –ò–∑-–∑–∞ —Ç–æ–≥–æ, —á—Ç–æ –º—ã –Ω–µ —É–∫–∞–∑–∞–ª–∏ —Ç–∏–ø –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è, –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è,
—á—Ç–æ –±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å—Å—è `()` - –ø—É—Å—Ç–æ–π [–∫–æ—Ä—Ç–µ–∂][tuples].

[tuples]: primitive-types.html#tuples

```rust,ignore
    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");

    println!("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏–µ.");
```

–ú—ã —É–∂–µ –∏–∑—É—á–∏–ª–∏, —á—Ç–æ `println!()` - —ç—Ç–æ [–º–∞–∫—Ä–æ—Å][macro], –∫–æ—Ç–æ—Ä—ã–π –≤—ã–≤–æ–¥–∏—Ç 
[—Å—Ç—Ä–æ–∫–∏][strings] –Ω–∞ —ç–∫—Ä–∞–Ω.

[macros]: macros.html
[strings]: strings.html

```rust,ignore
    let mut guess = String::new();
```

–¢–µ–ø–µ—Ä—å –∏–Ω—Ç–µ—Ä–µ—Å–Ω–µ–µ! –ö–∞–∫ –∂–µ –º–Ω–æ–≥–æ –≤—Å–µ–≥–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–µ! –ü–µ—Ä–≤–∞—è –≤–µ—â—å, –Ω–∞ 
–∫–æ—Ç–æ—Ä—É—é —Å–ª–µ–¥—É–µ—Ç –æ–±—Ä–∞—Ç–∏—Ç—å –≤–Ω–∏–º–∞–Ω–∏–µ - [–≤—ã—Ä–∞–∂–µ–Ω–∏–µ let][let], –∫–æ—Ç–æ—Ä–æ–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è 
–¥–ª—è `—Å–æ–∑–¥–∞–Ω–∏—è —Å–≤—è–∑–∏`. –û–Ω–æ –≤—ã–≥–ª—è–¥–∏—Ç —Ç–∞–∫:

```rust,ignore
let foo = bar;
```

[let]: variable-bindings.html

–≠—Ç–æ —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é —Å–≤—è–∑—å —Å –∏–º–µ–Ω–µ–º `foo` –∏ –ø—Ä–∏–≤—è–∑—ã–≤–∞–µ—Ç –µ–π –∑–Ω–∞—á–µ–Ω–∏–µ `bar`. –í–æ 
–º–Ω–æ–≥–∏—Ö —è–∑—ã–∫–∞—Ö —ç—Ç–æ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è `–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è`, –Ω–æ –≤ Rust —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏–º–µ–µ—Ç
–Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç—Ä—é–∫–æ–≤ –≤ —Ä—É–∫–∞–≤–µ.

–ù–∞–ø—Ä–∏–º–µ—Ä, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, —Å–≤—è–∑–∏ [–Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã][immutable]. –ü–æ —ç—Ç–æ–π –ø—Ä–∏—á–∏–Ω–µ –Ω–∞—à –ø—Ä–∏–º–µ—Ä
–∏—Å–ø–æ–ª—å–∑—É–µ—Ç `mut`: —ç—Ç–æ—Ç –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Ä–∞–∑—Ä–µ—à–∞–µ—Ç –º–µ–Ω—è—Ç—å —Å–≤—è–∑—å. –° —Å—Ç–æ—Ä–æ–Ω—ã —É `let` –º–æ–∂–µ—Ç
–±—ã—Ç—å –Ω–µ –ø—Ä–æ—Å—Ç–æ –∏–º—è —Å–≤—è–∑–∏, –∞ [–æ–±—Ä–∞–∑–µ—Ü][patterns]. –ú—ã –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏ –¥–∞–ª—å—à–µ.
–ò—Ö –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–æ—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:

```
let foo = 5; // –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–∞—è —Å–≤—è–∑—å
let mut bar = 5; // –∏–∑–º–µ–Ω—è–µ–º–∞—è —Å–≤—è–∑—å
```

[immutable]: mutability.html
[patterns]: patterns.html

–ê—Ö –¥–∞, `//` –Ω–∞—á–∏–Ω–∞–µ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π, –∫–æ—Ç–æ—Ä—ã–π –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –≤ –∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫–∏. Rust 
–∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –≤—Å—ë, —á—Ç–æ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ [–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è—Ö][comments].

[comments]: comments.html

–¢–µ–ø–µ—Ä—å –º—ã –∑–Ω–∞–µ–º, —á—Ç–æ `let mut guess` –æ–±—ä—è–≤–ª—è–µ—Ç –∏–∑–º–µ–Ω—è–µ–º—É—é —Å–≤—è–∑—å —Å –∏–º–µ–Ω–µ–º `guess`,
–Ω–æ –ø–æ –¥—Ä—É–≥—É—é —Å—Ç–æ—Ä–æ–Ω—É –æ—Ç `=` - —ç—Ç–æ —Ç–æ, —á—Ç–æ –±—É–¥–µ—Ç –ø—Ä–∏–≤—è–∑–∞–Ω–æ: `String::new()`.

`String` - —ç—Ç–æ —Å—Ç—Ä–æ–∫–æ–≤—ã–π —Ç–∏–ø, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—ã–π –Ω–∞–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π.
[`String`][string] - —ç—Ç–æ —Ç–µ–∫—Å—Ç –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8 –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –¥–ª–∏–Ω—ã.

[string]: ../std/string/struct.String.html

–°–∏–Ω—Ç–∞–∫—Å–∏—Å `::new()` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `::`, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –ø—Ä–∏–≤—è–∑–∞–Ω–Ω–∞—è –∫ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–º—É 
—Ç–∏–ø—É —Ñ—É–Ω–∫—Ü–∏—è. –¢–æ –µ—Å—Ç—å, –æ–Ω–∞ –ø—Ä–∏–≤—è–∑–∞–Ω–∞ –∫ —Å–∞–º–æ–º—É —Ç–∏–ø—É `String`, –∞ –Ω–µ –∫ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–π
–ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Ç–∏–ø–∞ `String`. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ —è–∑—ã–∫–∏ –Ω–∞–∑—ã–≤–∞—é—Ç —ç—Ç–æ "—Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–º –º–µ—Ç–æ–¥–æ–º".

–ò–º—è —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ - `new()`, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∞ —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—ã–π, –ø—É—Å—Ç–æ–π `String`. –í—ã 
–º–æ–∂–µ—Ç–µ –Ω–∞–π—Ç–∏ —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é —É –º–Ω–æ–≥–∏—Ö —Ç–∏–ø–æ–≤, –ø–æ—Ç–æ–º—É —á—Ç–æ —ç—Ç–æ –æ–±—â–µ–µ –∏–º—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è
–Ω–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞.

–î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏ –¥–∞–ª—å—à–µ:

```rust,ignore
    io::stdin().read_line(&mut guess)
        .ok()
        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Å—Ç—Ä–æ–∫—É");
```

–≠—Ç–æ —É–∂–µ –ø–æ–±–æ–ª—å—à–µ! –î–∞–≤–∞–π—Ç–µ —ç—Ç–æ –≤—Å—ë —Ä–∞–∑–±–µ—Ä—ë–º. –í –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ –µ—Å—Ç—å –¥–≤–µ —á–∞—Å—Ç–∏.
–≠—Ç–æ –ø–µ—Ä–≤–∞—è:

```rust,ignore
io::stdin()
```

–ü–æ–º–Ω–∏—Ç–µ, –∫–∞–∫ –º—ã –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–ª–∏ (`use`) `std::io` –≤ —Å–∞–º–æ–º –Ω–∞—á–∞–ª–µ –Ω–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã?
–°–µ–π—á–∞—Å –º—ã –≤—ã–∑–≤–∞–ª–∏ –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å –Ω–∏–º —Ñ—É–Ω–∫—Ü–∏—é. –ï—Å–ª–∏ –±—ã –º—ã –Ω–µ —Å–¥–µ–ª–∞–ª–∏ `use std::io`,
–Ω–∞–º –±—ã –ø—Ä–∏—à–ª–æ—Å—å –∑–¥–µ—Å—å –Ω–∞–ø–∏—Å–∞—Ç—å `std::io::stdin()`.

–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ –≤–≤–æ–¥–∞ –Ω–∞—à–µ–≥–æ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞. –ë–æ–ª–µ–µ 
–ø–æ–¥—Ä–æ–±–Ω–æ –æ–± —ç—Ç–æ –º–æ–∂–Ω–æ –ø–æ—á–∏—Ç–∞—Ç—å –≤ [std::io::Stdin][iostdin].

[iostdin]: http://doc.rust-lang.org/std/io/struct.Stdin.html

–°–ª–µ–¥—É—é—â–∞—è —á–∞—Å—Ç—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —ç—Ç–æ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ–≥–æ, —á—Ç–æ –≤–≤–µ–¥—ë—Ç 
–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:

```rust,ignore
.read_line(&mut guess)
```

–ó–¥–µ—Å—å –º—ã –≤—ã–∑–≤–∞–ª–∏ –º–µ—Ç–æ–¥ [`read_line()`][read_line] –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞. [–ú–µ—Ç–æ–¥—ã][methos]
–ø–æ—Ö–æ–∂–∏ –Ω–∞ –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –Ω–æ –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ —É –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞
—Ç–∏–ø–∞, –∞ –Ω–µ —Å–∞–º–æ–≥–æ —Ç–∏–ø–∞. –ú—ã —É–∫–∞–∑–∞–ª–∏ –æ–¥–∏–Ω –∞—Ä–≥—É–º–µ–Ω—Ç —Ñ—É–Ω–∫—Ü–∏–∏ `read_line()`: `&mut guess`.

[read_line]: http://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line
[method]: methods.html

–ü–æ–º–Ω–∏—Ç–µ, –∫–∞–∫ –º—ã –≤—ã—à–µ –ø—Ä–∏–≤—è–∑–∞–ª–∏ `guess`? –ú—ã —Å–∫–∞–∑–∞–ª–∏, —á—Ç–æ –æ–Ω–∞ –∏–∑–º–µ–Ω—è–µ–º–∞. –û–¥–Ω–∞–∫–æ,
`read_line` –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ `String`: –æ–Ω–∞ –ø–æ–ª—É—á–∞–µ—Ç `&mut String`.
–í Rust –µ—Å—Ç—å —Ç–∞–∫–∞—è –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å, –Ω–∞–∑—ã–≤–∞–µ–º–∞—è ["—Å—Å—ã–ª–∫–∏"][references], –∫–æ—Ç–æ—Ä–∞—è
–ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –∏–º–µ—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Å—ã–ª–æ–∫ –Ω–∞ –æ–¥–Ω–∏ –∏ —Ç–∞–∫ –∂–µ –¥–∞–Ω–Ω—ã–µ, —á—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç 
–∏–∑–±–µ–∂–∞—Ç—å –∏–∑–ª–∏—à–Ω–µ–≥–æ –∏—Ö –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è. –°—Å—ã–ª–∫–∏ - –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å–ª–æ–∂–Ω–∞—è –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å, –∏
–æ–¥–Ω–∏–º –∏–∑ –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø–æ–¥–∫—É–ø–∞—é—â–∏—Ö –¥–æ—Å—Ç–æ–∏–Ω—Å—Ç–≤ Rust —è–≤–ª—è–µ—Ç—Å—è —Ç–æ, –∫–∞–∫ –æ–Ω —Ä–µ—à–∞–µ—Ç –≤–æ–ø—Ä–æ—Å 
–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏ –ø—Ä–æ—Å—Ç–æ—Ç—ã –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è. –ü–æ–∫–∞ —á—Ç–æ –º—ã –Ω–µ –¥–æ–ª–∂–Ω—ã –∑–Ω–∞—Ç—å –æ–± —ç—Ç–∏—Ö 
–¥–µ—Ç–∞–ª—è—Ö, —á—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å –Ω–∞—à—É –ø—Ä–æ–≥—Ä–∞–º–º—É. –°–µ–π—á–∞—Å, –≤—Å—ë, —á—Ç–æ –Ω–∞–º –Ω—É–∂–Ω–æ - —ç—Ç–æ –∑–Ω–∞—Ç—å 
—á—Ç–æ —Å—Å—ã–ª–∫–∏, –∫–∞–∫ –∏ —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ –ø—Ä–∏ –ø–æ–º–æ—â–∏ `let`, –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é. 
–°–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –º—ã –¥–æ–ª–∂–Ω—ã –Ω–∞–ø–∏—Å–∞—Ç—å `&mut guess`, –∞ –Ω–µ `&guess`.

–ü–æ—á–µ–º—É `read_line()` –ø–æ–ª—É—á–∞–µ—Ç –∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ —Å—Ç—Ä–æ–∫—É? –ï–≥–æ —Ä–∞–±–æ—Ç–∞ - —ç—Ç–æ –≤–∑—è—Ç—å
—Ç–æ, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–ø–∏—Å–∞–ª –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤–≤–æ–¥, –∏ –ø–æ–ª–æ–∂–∏—Ç—å —ç—Ç–æ –≤ —Å—Ç—Ä–æ–∫—É. –ò—Ç–∞–∫,
—Ñ—É–Ω–∫—Ü–∏—è –ø–æ–ª—É—á–∞–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞, –∏ –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –≤ —ç—Ç—É 
—Å—Ç—Ä–æ–∫—É —á—Ç–æ-—Ç–æ, –æ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∏–∑–º–µ–Ω—è–µ–º–æ–π.

[references]: references-and-borrowing.html

But we‚Äôre not quite done with this line of code, though. While it‚Äôs
a single line of text, it‚Äôs only the first part of the single logical line of
code:

```rust,ignore
        .ok()
        .expect("Failed to read line");
```

When you call a method with the `.foo()` syntax, you may introduce a newline
and other whitespace. This helps you split up long lines. We _could_ have
done:

```rust,ignore
    io::stdin().read_line(&mut guess).ok().expect("failed to read line");
```

But that gets hard to read. So we‚Äôve split it up, three lines for three
method calls. We already talked about `read_line()`, but what about `ok()`
and `expect()`? Well, we already mentioned that `read_line()` puts what
the user types into the `&mut String` we pass it. But it also returns
a value: in this case, an [`io::Result`][ioresult]. Rust has a number of
types named `Result` in its standard library: a generic [`Result`][result],
and then specific versions for sub-libraries, like `io::Result`.

[ioresult]: ../std/io/type.Result.html
[result]: ../std/result/enum.Result.html

The purpose of these `Result` types is to encode error handling information.
Values of the `Result` type, like any type, have methods defined on them. In
this case, `io::Result` has an `ok()` method, which says ‚Äòwe want to assume
this value is a successful one. If not, just throw away the error
information‚Äô. Why throw it away? Well, for a basic program, we just want to
print a generic error, as basically any issue means we can‚Äôt continue. The
[`ok()` method][ok] returns a value which has another method defined on it:
`expect()`. The [`expect()` method][expect] takes a value it‚Äôs called on, and
if it isn‚Äôt a successful one, [`panic!`][panic]s with a message you passed you
passed it. A `panic!` like this will cause our program to crash, displaying
the message.

[ok]: ../std/result/enum.Result.html#method.ok
[expect]: ../std/option/enum.Option.html#method.expect
[panic]: error-handling.html

If we leave off calling these two methods, our program will compile, but
we‚Äôll get a warning:

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

Rust warns us that we haven‚Äôt used the `Result` value. This warning comes from
a special annotation that `io::Result` has. Rust is trying to tell you that
you haven‚Äôt handled a possible error. The right way to suppress the error is
to actually write error handling. Luckily, if we just want to crash if there‚Äôs
a problem, we can use these two little methods. If we can recover from the
error somehow, we‚Äôd do something else, but we‚Äôll save that for a future
project.

There‚Äôs just one line of this first example left:

```rust,ignore
    println!("You guessed: {}", guess);
}
```

This prints out the string we saved our input in. The `{}`s are a placeholder,
and so we pass it `guess` as an argument. If we had multiple `{}`s, we would
pass multiple arguments:

```rust
let x = 5;
let y = 10;

println!("x and y: {} and {}", x, y);
```

Easy.

Anyway, that‚Äôs the tour. We can run what we have with `cargo run`:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

All right! Our first part is done: we can get input from the keyboard,
and then print it back out.

# Generating a secret number

Next, we need to generate a secret number. Rust does not yet include random
number functionality in its standard library. The Rust team does, however,
provide a [`rand` crate][randcrate]. A ‚Äòcrate‚Äô is a package of Rust code.
We‚Äôve been building a ‚Äòbinary crate‚Äô, which is an executable. `rand` is a
‚Äòlibrary crate‚Äô, which contains code that‚Äôs intended to be used with other
programs.

[randcrate]: https://crates.io/crates/rand

Using external crates is where Cargo really shines. Before we can write
the code using `rand`, we need to modify our `Cargo.toml`. Open it up, and
add these few lines at the bottom:

```toml
[dependencies]

rand="0.3.0"
```

The `[dependencies]` section of `Cargo.toml` is like the `[package]` section:
everything that follows it is part of it, until the next section starts.
Cargo uses the dependencies section to know what dependencies on external
crates you have, and what versions you require. In this case, we‚Äôve used version `0.3.0`.
Cargo understands [Semantic Versioning][semver], which is a standard for writing version
numbers. If we wanted to use the latest version we could use `*` or we could use a range 
of versions. [Cargo‚Äôs documentation][cargodoc] contains more details.

[semver]: http://semver.org
[cargodoc]: http://doc.crates.io/crates-io.html

Now, without changing any of our code, let‚Äôs build our project:

```bash
$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.8
 Downloading libc v0.1.6
   Compiling libc v0.1.6
   Compiling rand v0.3.8
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
```

(You may see different versions, of course.)

Lots of new output! Now that we have an external dependency, Cargo fetches the
latest versions of everything from the registry, which is a copy of data from
[Crates.io][cratesio]. Crates.io is where people in the Rust ecosystem
post their open source Rust projects for others to use.

[cratesio]: https://crates.io

After updating the registry, Cargo checks our `[dependencies]` and downloads
any we don‚Äôt have yet. In this case, while we only said we wanted to depend on
`rand`, we‚Äôve also grabbed a copy of `libc`. This is because `rand` depends on
`libc` to work. After downloading them, it compiles them, and then compiles
our project.

If we run `cargo build` again, we‚Äôll get different output:

```bash
$ cargo build
```

That‚Äôs right, no output! Cargo knows that our project has been built, and that
all of its dependencies are built, and so there‚Äôs no reason to do all that
stuff. With nothing to do, it simply exits. If we open up `src/main.rs` again,
make a trivial change, and then save it again, we‚Äôll just see one line:

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
```

So, we told Cargo we wanted any `0.3.x` version of `rand`, and so it fetched the latest
version at the time this was written, `v0.3.8`. But what happens when next
week, version `v0.3.9` comes out, with an important bugfix? While getting
bugfixes is important, what if `0.3.9` contains a regression that breaks our
code?

The answer to this problem is the `Cargo.lock` file you‚Äôll now find in your
project directory. When you build your project for the first time, Cargo
figures out all of the versions that fit your criteria, and then writes them
to the `Cargo.lock` file. When you build your project in the future, Cargo
will see that the `Cargo.lock` file exists, and then use that specific version
rather than do all the work of figuring out versions again. This lets you
have a repeatable build automatically. In other words, we‚Äôll stay at `0.3.8`
until we explicitly upgrade, and so will anyone who we share our code with,
thanks to the lock file.

What about when we _do_ want to use `v0.3.9`? Cargo has another command,
`update`, which says ‚Äòignore the lock, figure out all the latest versions that
fit what we‚Äôve specified. If that works, write those versions out to the lock
file‚Äô. But, by default, Cargo will only look for versions larger than `0.3.0`
and smaller than `0.4.0`. If we want to move to `0.4.x`, we‚Äôd have to update
the `Cargo.toml` directly. When we do, the next time we `cargo build`, Cargo
will update the index and re-evaluate our `rand` requirements.

There‚Äôs a lot more to say about [Cargo][doccargo] and [its
ecosystem][doccratesio], but for now, that‚Äôs all we need to know. Cargo makes
it really easy to re-use libraries, and so Rustaceans tend to write smaller
projects which are assembled out of a number of sub-packages.

[doccargo]: http://doc.crates.io
[doccratesio]: http://doc.crates.io/crates-io.html

Let‚Äôs get on to actually _using_ `rand`. Here‚Äôs our next step:

```rust,ignore
extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .ok()
        .expect("failed to read line");

    println!("You guessed: {}", guess);
}
```

The first thing we‚Äôve done is change the first line. It now says
`extern crate rand`. Because we declared `rand` in our `[dependencies]`, we
can use `extern crate` to let Rust know we‚Äôll be making use of it. This also
does the equivalent of a `use rand;` as well, so we can make use of anything
in the `rand` crate by prefixing it with `rand::`.

Next, we added another `use` line: `use rand::Rng`. We‚Äôre going to use a
method in a moment, and it requires that `Rng` be in scope to work. The basic
idea is this: methods are defined on something called ‚Äòtraits‚Äô, and for the
method to work, it needs the trait to be in scope. For more about the
details, read the [traits][traits] section.

[traits]: traits.html

There are two other lines we added, in the middle:

```rust,ignore
    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);
```

We use the `rand::thread_rng()` function to get a copy of the random number
generator, which is local to the particular [thread][concurrency] of execution
we‚Äôre in. Because we `use rand::Rng`‚Äôd above, it has a `gen_range()` method
available. This method takes two arguments, and generates a number between
them. It‚Äôs inclusive on the lower bound, but exclusive on the upper bound,
so we need `1` and `101` to get a number between one and a hundred.

[concurrency]: concurrency.html

The second line just prints out the secret number. This is useful while
we‚Äôre developing our program, so we can easily test it out. But we‚Äôll be
deleting it for the final version. It‚Äôs not much of a game if it prints out
the answer when you start it up!

Try running our new program a few times:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```

Great! Next up: let‚Äôs compare our guess to the secret guess.

# Comparing guesses

Now that we‚Äôve got user input, let‚Äôs compare our guess to the random guess.
Here‚Äôs our next step, though it doesn‚Äôt quite work yet:

```rust,ignore
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .ok()
        .expect("failed to read line");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less    => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal   => println!("You win!"),
    }
}
```

A few new bits here. The first is another `use`. We bring a type called
`std::cmp::Ordering` into scope. Then, five new lines at the bottom that use
it:

```rust,ignore
match guess.cmp(&secret_number) {
    Ordering::Less    => println!("Too small!"),
    Ordering::Greater => println!("Too big!"),
    Ordering::Equal   => println!("You win!"),
}
```

The `cmp()` method can be called on anything that can be compared, and it
takes a reference to the thing you want to compare it to. It returns the
`Ordering` type we `use`d earlier. We use a [`match`][match] statement to
determine exactly what kind of `Ordering` it is. `Ordering` is an
[`enum`][enum], short for ‚Äòenumeration‚Äô, which looks like this:

```rust
enum Foo {
    Bar,
    Baz,
}
```

[match]: match.html
[enum]: enums.html

With this definition, anything of type `Foo` can be either a
`Foo::Bar` or a `Foo::Baz`. We use the `::` to indicate the
namespace for a particular `enum` variant.

The [`Ordering`][ordering] enum has three possible variants: `Less`, `Equal`,
and `Greater`. The `match` statement takes a value of a type, and lets you
create an ‚Äòarm‚Äô for each possible value. Since we have three types of
`Ordering`, we have three arms:

```rust,ignore
match guess.cmp(&secret_number) {
    Ordering::Less    => println!("Too small!"),
    Ordering::Greater => println!("Too big!"),
    Ordering::Equal   => println!("You win!"),
}
```

[ordering]: ../std/cmp/enum.Ordering.html

If it‚Äôs `Less`, we print `Too small!`, if it‚Äôs `Greater`, `Too big!`, and if
`Equal`, `You win!`. `match` is really useful, and is used often in Rust.

I did mention that this won‚Äôt quite work yet, though. Let‚Äôs try it:

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:28:21: 28:35 error: mismatched types:
 expected `&collections::string::String`,
    found `&_`
(expected struct `collections::string::String`,
    found integral variable) [E0308]
src/main.rs:28     match guess.cmp(&secret_number) {
                                   ^~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `guessing_game`.
```

Whew! This is a big error. The core of it is that we have ‚Äòmismatched types‚Äô.
Rust has a strong, static type system. However, it also has type inference.
When we wrote `let guess = String::new()`, Rust was able to infer that `guess`
should be a `String`, and so it doesn‚Äôt make us write out the type. And with
our `secret_number`, there are a number of types which can have a value
between one and a hundred: `i32`, a thirty-two-bit number, or `u32`, an
unsigned thirty-two-bit number, or `i64`, a sixty-four-bit number. Or others.
So far, that hasn‚Äôt mattered, and so Rust defaults to an `i32`. However, here,
Rust doesn‚Äôt know how to compare the `guess` and the `secret_number`. They
need to be the same type. Ultimately, we want to convert the `String` we
read as input into a real number type, for comparison. We can do that
with three more lines. Here‚Äôs our new program:

```rust,ignore
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .ok()
        .expect("failed to read line");

    let guess: u32 = guess.trim().parse()
        .ok()
        .expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less    => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal   => println!("You win!"),
    }
}
```

The new three lines:

```rust,ignore
    let guess: u32 = guess.trim().parse()
        .ok()
        .expect("Please type a number!");
```

Wait a minute, I thought we already had a `guess`? We do, but Rust allows us
to ‚Äòshadow‚Äô the previous `guess` with a new one. This is often used in this
exact situation, where `guess` starts as a `String`, but we want to convert it
to an `u32`. Shadowing lets us re-use the `guess` name, rather than forcing us
to come up with two unique names like `guess_str` and `guess`, or something
else.

We bind `guess` to an expression that looks like something we wrote earlier:

```rust,ignore
guess.trim().parse()
```

Followed by an `ok().expect()` invocation. Here, `guess` refers to the old
`guess`, the one that was a `String` with our input in it. The `trim()`
method on `String`s will eliminate any white space at the beginning and end of
our string. This is important, as we had to press the ‚Äòreturn‚Äô key to satisfy
`read_line()`. This means that if we type `5` and hit return, `guess` looks
like this: `5\n`. The `\n` represents ‚Äònewline‚Äô, the enter key. `trim()` gets
rid of this, leaving our string with just the `5`. The [`parse()` method on
strings][parse] parses a string into some kind of number. Since it can parse a
variety of numbers, we need to give Rust a hint as to the exact type of number
we want. Hence, `let guess: u32`. The colon (`:`) after `guess` tells Rust
we‚Äôre going to annotate its type. `u32` is an unsigned, thirty-two bit
integer. Rust has [a number of built-in number types][number], but we‚Äôve
chosen `u32`. It‚Äôs a good default choice for a small positive numer.

[parse]: ../std/primitive.str.html#method.parse
[number]: primitive-types.html#numeric-types

Just like `read_line()`, our call to `parse()` could cause an error. What if
our string contained `Aüëç%`? There‚Äôd be no way to convert that to a number. As
such, we‚Äôll do the same thing we did with `read_line()`: use the `ok()` and
`expect()` methods to crash if there‚Äôs an error.

Let‚Äôs try our program out!

```bash
$ cargo run
   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

Nice! You can see I even added spaces before my guess, and it still figured
out that I guessed 76. Run the program a few times, and verify that guessing
the number works, as well as guessing a number too small.

Now we‚Äôve got most of the game working, but we can only make one guess. Let‚Äôs
change that by adding loops!

# Looping

The `loop` keyword gives us an infinite loop. Let‚Äôs add that in:

```rust,ignore
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .ok()
            .expect("failed to read line");

        let guess: u32 = guess.trim().parse()
            .ok()
            .expect("Please type a number!");

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => println!("You win!"),
        }
    }
}
```

And try it out. But wait, didn‚Äôt we just add an infinite loop? Yup. Remember
our discussion about `parse()`? If we give a non-number answer, we‚Äôll `return`
and quit. Observe:

```bash
$ cargo run
   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread '<main>' panicked at 'Please type a number!'
```

Ha! `quit` actually quits. As does any other non-number input. Well, this is
suboptimal to say the least. First, let‚Äôs actually quit when you win the game:

```rust,ignore
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .ok()
            .expect("failed to read line");

        let guess: u32 = guess.trim().parse()
            .ok()
            .expect("Please type a number!");

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => {
                println!("You win!");
                break;
            }
        }
    }
}
```

By adding the `break` line after the `You win!`, we‚Äôll exit the loop when we
win. Exiting the loop also means exiting the program, since it‚Äôs the last
thing in `main()`. We have just one more tweak to make: when someone inputs a
non-number, we don‚Äôt want to quit, we just want to ignore it. We can do that
like this:

```rust,ignore
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .ok()
            .expect("failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => {
                println!("You win!");
                break;
            }
        }
    }
}
```

These are the lines that changed:

```rust,ignore
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};
```

This is how you generally move from ‚Äòcrash on error‚Äô to ‚Äòactually handle the
error‚Äô, by switching from `ok().expect()` to a `match` statement. The `Result`
returned by `parse()` is an enum just like `Ordering`, but in this case, each
variant has some data associated with it: `Ok` is a success, and `Err` is a
failure. Each contains more information: the successful parsed integer, or an
error type. In this case, we `match` on `Ok(num)`, which sets the inner value
of the `Ok` to the name `num`, and then we just return it on the right-hand
side. In the `Err` case, we don‚Äôt care what kind of error it is, so we just
use `_` intead of a name. This ignores the error, and `continue` causes us
to go to the next iteration of the `loop`.

Now we should be good! Let‚Äôs try:

```bash
$ cargo run
   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```

Awesome! With one tiny last tweak, we have finished the guessing game. Can you
think of what it is? That‚Äôs right, we don‚Äôt want to print out the secret
number. It was good for testing, but it kind of ruins the game. Here‚Äôs our
final source:

```rust,ignore
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .ok()
            .expect("failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => {
                println!("You win!");
                break;
            }
        }
    }
}
```

# Complete!

At this point, you have successfully built the Guessing Game! Congratulations!

This first project showed you a lot: `let`, `match`, methods, associated
functions, using external crates, and more. Our next project will show off
even more.
