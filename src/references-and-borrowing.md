% Ссылки и Заимствование

Эта глава является одной из трех, описывающих систему владения ресурсами Rust.
Эта система представляет собой наиболее уникальную и привлекательную фичу Rust,
о которой разработчики на Rust должны иметь полное представление. Владение - это
то, как Rust достигает своей главной цели - безопасности памяти. Система
владения включает в себя несколько различных концепций, каждая из которых
рассматривается в своей собственной главе:

* [владение][ownership], ключевая концепция
* заимствование, ее вы сейчас читаете
* [время жизни][lifetimes], расширение концепции заимствования

Эти три главы взаимосвязаны, и их порядок важен. Вы должны будете освоить все
три главы, чтобы полностью понять систему владения.

[ownership]: ownership.html
[lifetimes]: lifetimes.html

# Мета

Прежде чем перейти к деталям, отметитм два важных нюанса о системе владения.

Rust сфокусирован на безопасности и скорости. Это достигается за счет
‘абстракций с нулевой стоимостью‘ (‘zero-cost abstractions‘), что означает, что
в Rust стоимость абстракций должна быть настолько минимальной, насколько это
возможно, без ущерба для работоспособности. Система владения ресурсами - это
яркий пример абстракции с нулевой стоимостью. Весь анализ, о котором мы будем
говорить в этом руководстве, выполняется _во время компиляции_. Вы не платите
хоть сколько-нибудь времени рантайма за какую-либо из фич.

Тем не менее, эта система все же имеет определенную стоимость: кривая обучения.
Многие новые пользователи Rust испытыват то, что мы называем ‘борьба с проверкой
заимствования‘, когда компилятор Rust отказывается компилировать программу,
которая по мнению автора является абсолютно правильной. Это часто происходит
потому, что мысленное представление программиста о том, как должно работать
владение, не совпадает с реальными правилами, которыми оперирует Rust. Вы,
наверное, также будете испытывать подобные трудности поначалу. Однако существует
и хорошая новость: более опытные разработчики на Rust сообщают, что чем больше
они работают с правилами системы владения, тем меньше они борются с проверкой
заимствования.

Имея это в виду, давайте перейдем к изучению систему владения.

# Заимствование

В конце главы [Владение][ownership], у нас была скверная функция, которая
выглядела так:

```rust
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
    // do stuff with v1 and v2

    // hand back ownership, and the result of our function
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
```

Однако, этот код не является идиоматическим с точки зрения Rust, так как он не
использует заимствование. Вот первый шаг:

```rust
fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
    // do stuff with v1 and v2

    // return the answer
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&v1, &v2);

// we can use v1 and v2 here!
```

Вместо того, чтобы принимать `Vec<i32>` в качестве аргументов, мы будем
принимать ссылки: `&Vec<i32>`. И вместо передачи `v1` и `v2` напрямую, мы будем
передавать `&v1` и `&v2`. Мы называем тип `&T` ‘ссылка‘, и вместо того, чтобы
забирать право владения ресурсом, она его заимствует. Привязки, которые
заимствуют что-то, не освобождают ресурс, когда они выходят из области
видимости. Это означает, что, после вызова `foo()`, мы снова можем использовать
наши оригинальные привязки.

Ссылки являются неизменяемыми, как и привязки. Это означает, что внутри `foo()`,
векторы не могут быть изменены:

```rust,ignore
fn foo(v: &Vec<i32>) {
     v.push(5);
}

let v = vec![];

foo(&v);
```

выдает ошибку:

```text
error: cannot borrow immutable borrowed content `*v` as mutable
v.push(5);
^
```

Добавление значения изменяет вектор, и поэтому компилятор не позволил нам это
сделать.

# &mut ссылки

Вот второй вид ссылок: `&mut T`. Это ‘изменяемая ссылка‘, которая позволяет
изменять ресурс, который вы заимствуете. Например:

```rust
let mut x = 5;
{
    let y = &mut x;
    *y += 1;
}
println!("{}", x);
```

Этот код напечатает `6`. Мы создали `y`, изменяемую ссылку на `x`, а затем
добавили единицу к значению, на которое указывает `y`. Следует отметить, что `x`
также должна быть помечена как `mut`, если бы этого не было, то мы не могли бы
взять изменяемый заем неизменяемого значения.

Во всем остальном изменяемые ссылки (`&mut`) такие же, как и неизменяемые (`&`).
Однако, существует большая разница между этими двумя концепциями, и тем, как они
взаимодействуют. Вы можете сказать, что в приведенном выше примере есть что-то
подозрительное, потому что нам зачем-то понадобилась дополнительная область
видимости, созданная с помощью `{` и `}`. Если мы уберем эти скобки, то получим
ошибку:

```text
error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!("{}", x);
                   ^
note: previous borrow of `x` occurs here; the mutable borrow prevents
subsequent moves, borrows, or modification of `x` until the borrow ends
        let y = &mut x;
                     ^
note: previous borrow ends here
fn main() {

}
^
```

Как оказалось, есть правила.

<a name="The-Rules"></a>
# Правила

Вот правила о заимствовании в Rust:

Во-первых, область видимости любого заема должна находиться в пределах области
видимости владельца. Во-вторых, одновременно у вас может быть только один из
двух перечисленных ниже видов заимствования, но не оба сразу:

* от 0 до N неизменяемых ссылок (`&T`) на ресурс,
* ровно одна изменяемая ссылка (`&mut T`) на ресурс.


Вы можете заметить, что они очень похожи, хотя и не совсем то же самое,
относительно определения состояния гонки данных:

> Состояние ’гонки данных’ возникает, когда два или более указателей имеют
> доступ к одной и той же области памяти одновременно, и когда по крайней мере
> один из них производит запись, а операции не синхронизированы.

Что касается неизменяемых ссылок, то вы можете иметь их столько, сколько хотите,
так как ни одна из них не производит запись. Если же вы производите запись, и
вам нужно два или больше указателей на одну и ту же область памяти, то вы можете
иметь только один `&mut` одновременно. Это то как Rust предотвращает
возникновение состояния гонки данных во время компиляции: мы получим ошибки,
если мы нарушим эти правила.

Имея это в виду, давайте рассмотрим наш пример еще раз.

## Мысли об областях видимости (Thinking in scopes)

Вот код:

```rust,ignore
let mut x = 5;
let y = &mut x;

*y += 1;

println!("{}", x);
```

Этот код выдает нам такую ошибку:

```text
error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!("{}", x);
                   ^
```

Это потому, что мы нарушили правила: у нас есть изменяемая ссылка `&mut T`,
указывающая на `x`, и поэтому мы не можем создать какую-либо `&T`. Одно из двух.
Примечание подсказывает как следует рассматривать эту проблему:

```text
note: previous borrow ends here
fn main() {

}
^
```

Другими словами, изменяемая ссылка сохраняется до конца нашего примера. А мы
хотим, чтобы изменяемый заем заканчивался _до_ того, как мы пытаемся вызвать
`println!` и создать неизменяемый заем. В Rust заимствование привязано к области
видимости, в которой оно является действительным. И эти области видимости
выглядят следующим образом:

```rust,ignore
let mut x = 5;

let y = &mut x;    // -+ &mut borrow of x starts here
                   //  |
*y += 1;           //  |
                   //  |
println!("{}", x); // -+ - try to borrow x here
                   // -+ &mut borrow of x ends here
```

Конфликт областей видимости: мы не можем создать `&x` до тех пор, пока `y`
находится в области видимости.

Поэтому, когда мы добавляем фигурные скобки:

```rust
let mut x = 5;

{                   
    let y = &mut x; // -+ &mut borrow starts here
    *y += 1;        //  |
}                   // -+ ... and ends here

println!("{}", x);  // <- try to borrow x here
```

Никаких проблем нет. Наш изменяемый заем выходит из области видимости до
создания неизменяемого. Но область видимости является ключом к определению того,
как долго длится заем.

## Проблемы, которые предотвращает заимствование

Почему нужны эти ограничивающие правила? Ну, как мы уже отметили, эти правила
предотвращают гонки данных. Какие виды проблем могут привести к состоянию гонки
данных? Вот некоторые из них.

### Недействительный итератор

Одним из примеров является ’недействительный итератор’, такое может произойти,
когда вы пытаетесь изменить коллекцию, которую в данный момент итерируете.
Проверка заимствования Rust предотвращает это:

```rust
let mut v = vec![1, 2, 3];

for i in &v {
    println!("{}", i);
}
```

Этот код печатает от одного до трех. Так как мы итерируем по вектору, мы
получаем лишь ссылки на элементы. И сам `v` заимствован как неизменяемый, что
означает, что мы не можем изменить его в процессе итерирования:

```rust,ignore
let mut v = vec![1, 2, 3];

for i in &v {
    println!("{}", i);
    v.push(34);
}
```

Вот ошибка:

```text
error: cannot borrow `v` as mutable because it is also borrowed as immutable
    v.push(34);
    ^
note: previous borrow of `v` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `v` until the borrow ends
for i in &v {
          ^
note: previous borrow ends here
for i in &v {
    println!(“{}”, i);
    v.push(34);
}
^
```

Мы не можем изменить `v`, потому что он уже заимствован в цикле.

### Использование после освобождения (use after free)

Ссылки должны жить так же долго, как и ресурс, на который они ссылаются. Rust
проверяет области видимоси ваших ссылок, чтобы удостовериться, что это правда.

Если Rust не будет проверять это свойство, то мы можем случайно использовать
ссылку, которая будет недействительна. Например:

```rust,ignore
let y: &i32;
{ 
    let x = 5;
    y = &x;
}

println!("{}", y);
```

Мы получим следующую ошибку:

```text
error: `x` does not live long enough
    y = &x;
         ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
let y: &i32;
{ 
    let x = 5;
    y = &x;
}

note: ...but borrowed value is only valid for the block suffix following
statement 0 at 4:18
    let x = 5;
    y = &x;
}
```

Другими словами, `y` действителен только для той области видимости, где
существует `x`. Как только `x` выходит из области видимости, ссылка на него
становится недействительной. Таким образом, ошибка сообщает, что заем ‘does not
live long enough‘ (‘не живет достаточно долго‘), потому что он не является
действительным столько времени, сколько требуется.
