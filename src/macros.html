<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Макросы</title>

    <link rel="stylesheet" type="text/css" href="../rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../src/INTRODUCTION.html'><b>2.</b> Введение</a>
</li>
<li><a  href='../src/getting-started.html'><b>3.</b> C чего начать</a>
<ul class='section'>
<li><a  href='../src/installing-rust.html'><b>3.1.</b> Установка Rust</a>
</li>
<li><a  href='../src/hello-world.html'><b>3.2.</b> Привет, мир!</a>
</li>
<li><a  href='../src/hello-cargo.html'><b>3.3.</b> Hello, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='../src/learn-rust.html'><b>4.</b> Изучение Rust</a>
<ul class='section'>
<li><a  href='../src/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
<li><a  href='../src/dining-philosophers.html'><b>4.2.</b> Обедающие философы</a>
</li>
<li><a  href='../src/rust-inside-other-languages.html'><b>4.3.</b> Вызов кода на Rust из других языков</a>
</li>
</ul>
</li>
<li><a  href='../src/effective-rust.html'><b>5.</b> Эффективное использование Rust</a>
<ul class='section'>
<li><a  href='../src/the-stack-and-the-heap.html'><b>5.1.</b> Стек и куча</a>
</li>
<li><a  href='../src/testing.html'><b>5.2.</b> Тестирование</a>
</li>
<li><a  href='../src/conditional-compilation.html'><b>5.3.</b> Условная компиляция</a>
</li>
<li><a  href='../src/documentation.html'><b>5.4.</b> Документация</a>
</li>
<li><a  href='../src/iterators.html'><b>5.5.</b> Итераторы</a>
</li>
<li><a  href='../src/concurrency.html'><b>5.6.</b> Многозадачность</a>
</li>
<li><a  href='../src/error-handling.html'><b>5.7.</b> Обработка ошибок</a>
</li>
<li><a  href='../src/choosing-your-guarantees.html'><b>5.8.</b> Choosing your Guarantees</a>
</li>
<li><a  href='../src/ffi.html'><b>5.9.</b> Интерфейс внешних функций (FFI)</a>
</li>
<li><a  href='../src/borrow-and-asref.html'><b>5.10.</b> Типажи `Borrow` и `AsRef`</a>
</li>
<li><a  href='../src/release-channels.html'><b>5.11.</b> Каналы сборок</a>
</li>
</ul>
</li>
<li><a  href='../src/syntax-and-semantics.html'><b>6.</b> Синтаксис и семантика</a>
<ul class='section'>
<li><a  href='../src/variable-bindings.html'><b>6.1.</b> Связывание имён</a>
</li>
<li><a  href='../src/functions.html'><b>6.2.</b> Функции</a>
</li>
<li><a  href='../src/primitive-types.html'><b>6.3.</b> Простые типы</a>
</li>
<li><a  href='../src/comments.html'><b>6.4.</b> Комментарии</a>
</li>
<li><a  href='../src/if.html'><b>6.5.</b> Конструкция `if`</a>
</li>
<li><a  href='../src/loops.html'><b>6.6.</b> Циклы</a>
</li>
<li><a  href='../src/ownership.html'><b>6.7.</b> Владение</a>
</li>
<li><a  href='../src/references-and-borrowing.html'><b>6.8.</b> Ссылки и заимствование</a>
</li>
<li><a  href='../src/lifetimes.html'><b>6.9.</b> Время жизни</a>
</li>
<li><a  href='../src/mutability.html'><b>6.10.</b> Изменяемость (mutability)</a>
</li>
<li><a  href='../src/structs.html'><b>6.11.</b> Структуры</a>
</li>
<li><a  href='../src/enums.html'><b>6.12.</b> Перечисления</a>
</li>
<li><a  href='../src/match.html'><b>6.13.</b> Конструкция `match`</a>
</li>
<li><a  href='../src/patterns.html'><b>6.14.</b> Шаблоны сопоставления `match`</a>
</li>
<li><a  href='../src/method-syntax.html'><b>6.15.</b> Синтаксис методов</a>
</li>
<li><a  href='../src/vectors.html'><b>6.16.</b> Вектора</a>
</li>
<li><a  href='../src/strings.html'><b>6.17.</b> Строки</a>
</li>
<li><a  href='../src/generics.html'><b>6.18.</b> Обобщённое программирование</a>
</li>
<li><a  href='../src/traits.html'><b>6.19.</b> Типажи</a>
</li>
<li><a  href='../src/drop.html'><b>6.20.</b> Типаж `Drop` (сброс)</a>
</li>
<li><a  href='../src/if-let.html'><b>6.21.</b> Конструкция `if let`</a>
</li>
<li><a  href='../src/trait-objects.html'><b>6.22.</b> Типажи-объекты</a>
</li>
<li><a  href='../src/closures.html'><b>6.23.</b> Замыкания</a>
</li>
<li><a  href='../src/ufcs.html'><b>6.24.</b> Универсальный синтаксис вызова функций (UFCS)</a>
</li>
<li><a  href='../src/crates-and-modules.html'><b>6.25.</b> Контейнеры (crates) и модули (modules)</a>
</li>
<li><a  href='../src/const-and-static.html'><b>6.26.</b> `const` и `static`</a>
</li>
<li><a  href='../src/attributes.html'><b>6.27.</b> Атрибуты</a>
</li>
<li><a  href='../src/type-aliases.html'><b>6.28.</b> Псевдонимы типов</a>
</li>
<li><a  href='../src/casting-between-types.html'><b>6.29.</b> Приведение типов</a>
</li>
<li><a  href='../src/associated-types.html'><b>6.30.</b> Ассоциированные типы</a>
</li>
<li><a  href='../src/unsized-types.html'><b>6.31.</b> Безразмерные типы</a>
</li>
<li><a  href='../src/operators-and-overloading.html'><b>6.32.</b> Перегрузка операций</a>
</li>
<li><a  href='../src/deref-coercions.html'><b>6.33.</b> Преобразования при разыменовании (deref coercions)</a>
</li>
<li><a class='active' href='../src/macros.html'><b>6.34.</b> Макросы</a>
</li>
<li><a  href='../src/raw-pointers.html'><b>6.35.</b> Сырые указатели</a>
</li>
<li><a  href='../src/unsafe.html'><b>6.36.</b> Небезопасный код</a>
</li>
</ul>
</li>
<li><a  href='../src/nightly-rust.html'><b>7.</b> Нестабильные возможности Rust</a>
<ul class='section'>
<li><a  href='../src/compiler-plugins.html'><b>7.1.</b> Плагины к компилятору</a>
</li>
<li><a  href='../src/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a  href='../src/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a  href='../src/intrinsics.html'><b>7.4.</b> Внутренние средства (intrinsics)</a>
</li>
<li><a  href='../src/lang-items.html'><b>7.5.</b> Элементы языка (lang items)</a>
</li>
<li><a  href='../src/advanced-linking.html'><b>7.6.</b> Продвинутое руководство по компоновке (advanced linking)</a>
</li>
<li><a  href='../src/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a  href='../src/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a  href='../src/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a  href='../src/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
</ul>
</li>
<li><a  href='../src/glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a  href='../src/academic-research.html'><b>9.</b> Академические исследования</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Макросы</h1>
    <p>К этому моменту вы узнали о многих инструментах Rust, которые нацелены на
абстрагирование и повторное использование кода. Эти единицы повторно
использованного кода имеют богатую смысловую структуру. Например, функции имеют
сигнатуры типа, типы параметров могут имеют ограничения по типажам,
перегруженные функции также могут принадлежать к определенному типажу.</p>

<p>Эта структура означает, что ключевые абстракции Rust имеют мощный механизм
проверки времени компиляции. Но это достигается за счет снижения гибкости. Если
вы визуально определите структуру повторно используемого кода, то вы можете
найти трудным или громоздким выражение этой схемы в виде обобщённой функции,
типажа, или чего-то еще в семантике Rust.</p>

<p>Макросы позволяют абстрагироваться на <em>синтаксическом</em> уровне. Вызов макроса
является сокращением для «расширенной» синтаксической формы. Это расширение
происходит в начале компиляции, до начала статической проверки. В результате,
макросы могут охватить много шаблонов повторного использования кода, которые
невозможны при использовании лишь ключевых абстракций Rust.</p>

<p>Недостатком является то, что код, основанный на макросах, может быть трудным для
понимания, потому что к нему применяется меньше встроенных правил. Подобно
обычной функции, качественный макрос может быть использован без понимания его
реализации. Тем не менее, может быть трудно разработать качественный макрос!
Кроме того, ошибки компилятора в макро коде сложнее интерпретировать, потому что
они описывают проблемы в расширенной форме кода, а не в исходной сокращенной
форме кода, которую используют разработчики.</p>

<p>Эти недостатки делают макросы чем-то вроде «возможности последней инстанции».
Это не означает, что макросы это плохо; они являются частью Rust, потому что
иногда они все же нужны для по-настоящему краткой записи хорошо абстрагированной
части кода. Просто имейте этот компромисс в виду.</p>

<h1 id='Определение-макросов-Макроопределения' class='section-header'><a href='#Определение-макросов-Макроопределения'>Определение макросов (Макроопределения)</a></h1>
<p>Вы, возможно, видели макрос <code>vec!</code>, который используется для инициализации
<a href="vectors.html">вектора</a> с произвольным количеством элементов.</p>
<span class='rusttest'>fn main() {
    let x: Vec&lt;u32&gt; = vec![1, 2, 3];
    assert_eq!(x, [1, 2, 3]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];</pre>

<p>Его нельзя реализовать в виде обычной функции, так как он принимает любое
количество аргументов. Но мы можем представить его в виде синтаксического
сокращения для следующего кода</p>
<span class='rusttest'>fn main() {
    let x: Vec&lt;u32&gt; = {
        let mut temp_vec = Vec::new();
        temp_vec.push(1);
        temp_vec.push(2);
        temp_vec.push(3);
        temp_vec
    };
    assert_eq!(x, [1, 2, 3]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>temp_vec</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>1</span>);
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>2</span>);
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>3</span>);
    <span class='ident'>temp_vec</span>
};</pre>

<p>Мы можем реализовать это сокращение, используя макрос: <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<p>представленной здесь по соображениям эффективности и повторного использования.
Некоторые из них упомянуты в главе [продвинутые макросы][advanced macros
chapter].</p>
<span class='rusttest'>macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
fn main() {
    assert_eq!(vec![1,2,3], [1, 2, 3]);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>vec</span> {
    ( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ) <span class='op'>=&gt;</span> {
        {
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>temp_vec</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
            $(
                <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
            )<span class='op'>*</span>
            <span class='ident'>temp_vec</span>
        }
    };
}</pre>

<p>Ого, тут много нового синтаксиса! Давайте разберем его.</p>
<span class='rusttest'>fn main() {
    macro_rules! vec { ... }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>vec</span> { ... }</pre>

<p>Тут мы определяем макрос с именем <code>vec</code>, аналогично тому, как <code>fn vec</code>
определяло бы функцию с именем <code>vec</code>. При вызове мы неформально пишем имя
макроса с восклицательным знаком, например, <code>vec!</code>. Восклицательный знак
является частью синтаксиса вызова и служит для того, чтобы отличать макрос от
обычной функции.</p>

<h2 id='Сопоставление-matching-Синтаксис-вызова-макрокоманды' class='section-header'><a href='#Сопоставление-matching-Синтаксис-вызова-макрокоманды'>Сопоставление (Matching) (Синтаксис вызова макрокоманды)</a></h2>
<p>Макрос определяется с помощью ряда <em>правил</em>, которые представляют собой варианты
сопоставления с образцом. Выше у нас было</p>
<span class='rusttest'>fn main() {
    ( $( $x:expr ),* ) =&gt; { ... };
    
}</span><pre class='rust rust-example-rendered'>
( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ) <span class='op'>=&gt;</span> { ... };</pre>

<p>Это очень похоже на конструкцию <code>match</code>, но сопоставление происходит на уровне
синтаксических деревьев Rust, на этапе компиляции. Точка с запятой не является
обязательной для последнего (только здесь) варианта. «Образец» слева от <code>=&gt;</code>
известен как <em>шаблон совпадений</em> (<em>образец</em>) (<em>обнаружитель совпадений</em>)
(<em>matcher</em>). Он имеет <a href="https://doc.rust-lang.org/stable/reference.html#macros">свою собственную грамматику</a> в
рамках языка.</p>

<p>Образец <code>$x:expr</code> будет соответствовать любому выражению Rust, связывая его
дерево синтаксиса с <em>метапеременной</em> <code>$x</code>. Идентификатор <code>expr</code> является
<em>спецификатором фрагмента</em>; полные возможности перечислены в главе [продвинутые
макросы][advanced macros chapter]. Образец, окруженный <code>$(...),*</code>, будет
соответствовать нулю или более выражениям, разделенным запятыми.</p>

<p>За исключением специального синтаксиса сопоставления с образцом, любые другие
элементы Rust, которые появляются в образце, должны в точности совпадать.
Например,</p>
<span class='rusttest'>macro_rules! foo {
    (x =&gt; $e:expr) =&gt; (println!(&quot;mode X: {}&quot;, $e));
    (y =&gt; $e:expr) =&gt; (println!(&quot;mode Y: {}&quot;, $e));
}

fn main() {
    foo!(y =&gt; 3);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='ident'>x</span> <span class='op'>=&gt;</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;mode X: {}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));
    (<span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;mode Y: {}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='number'>3</span>);
}</pre>

<p>выведет</p>

<pre><code class="language-text">mode Y: 3
</code></pre>

<p>А с</p>
<span class='rusttest'>fn main() {
    foo!(z =&gt; 3);
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>z</span> <span class='op'>=&gt;</span> <span class='number'>3</span>);</pre>

<p>мы получим ошибку компиляции</p>

<pre><code class="language-text">error: no rules expected the token `z`
</code></pre>

<h2 id='Развертывание-expansion-Синтаксис-преобразования-макрокоманды' class='section-header'><a href='#Развертывание-expansion-Синтаксис-преобразования-макрокоманды'>Развертывание (Expansion) (Синтаксис преобразования макрокоманды)</a></h2>
<p>С правой стороны макро правил используется, по большей части, обычный синтаксис
Rust. Но мы можем соединить кусочки раздробленного синтаксиса, захваченные при
сопоставлении с соответствующим образцом. Из предыдущего примера:</p>
<span class='rusttest'>fn main() {
    $(
        temp_vec.push($x);
    )*
    
}</span><pre class='rust rust-example-rendered'>
$(
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
)<span class='op'>*</span></pre>

<p>Каждое соответствующее выражение <code>$x</code> будет генерировать одиночный оператор
<code>push</code> в развернутой форме макроса. Повторение в развернутой форме происходит
синхронно с повторением в форме образца (более подробно об этом чуть позже).</p>

<p>Поскольку <code>$x</code> уже объявлен в образце как выражение, мы не повторяем <code>:expr</code> с
правой стороны. Кроме того, мы не включаем разделителяющую запятую в качестве
части оператора повторения. Вместо этого, у нас есть точка с запятой в пределах
повторяемого блока.</p>

<p>Еще одна деталь: макрос <code>vec!</code> имеет <em>две</em> пары фигурных скобках правой части.
Они часто сочетаются таким образом:</p>
<span class='rusttest'>fn main() {
    macro_rules! foo {
        () =&gt; {{
            ...
        }}
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> {{
        ...
    }}
}</pre>

<p>Внешние скобки являются частью синтаксиса <code>macro_rules!</code>. На самом деле, вы
можете использовать <code>()</code> или <code>[]</code> вместо них. Они просто разграничивают правую
часть в целом.</p>

<p>Внутренние скобки являются частью расширенного синтаксиса. Помните, что макрос
<code>vec!</code> используется в контексте выражения. Мы используем блок, для записи
выражения с множественными операторами, в том числе включающее <code>let</code> привязки.
Если ваш макрос раскрывается в одно единственное выражение, то дополнительной
слой скобок не нужен.</p>

<p>Note that we never <em>declared</em> that the macro produces an expression. In fact,
this is not determined until we use the macro as an expression. With care, you
can write a macro whose expansion works in several contexts. For example,
shorthand for a data type could be valid as either an expression or a pattern.</p>

<p>Обратите внимание, что мы никогда не <em>говорили</em>, что макрос создает выражения.
На самом деле, это не определяется, пока мы не используем макрос в качестве
выражения. Если соблюдать осторожность, то можно написать макрос, развернутая
форма которого будет валидна сразу в нескольких контекстах. Например,
сокращенная форма для типа данных может быть валидной и как выражение, и как
шаблон.</p>

<h2 id='Повторение-repetition-Многовариантность' class='section-header'><a href='#Повторение-repetition-Многовариантность'>Повторение (Repetition) (Многовариантность)</a></h2>
<p>Операции повтора всегда сопутствуют два основных правила:</p>

<ol>
<li><code>$(...)*</code> проходит через один «слой» повторений, для всех <code>$name</code>, которые он
содержит, в ногу, и</li>
<li>каждое <code>$name</code> должно быть под, по крайней мере, стольким количеством
<code>$(...)*</code>, сколько было использовано при сопоставлении. Если оно под большим
числом <code>$(...)*</code>, <code>$name</code> будет дублироваться, при необходимости.</li>
</ol>

<p>This baroque macro illustrates the duplication of variables from outer
repetition levels.</p>

<p>Этот причудливый макрос иллюстрирует дублирования переменных из внешних уровней
повторения.</p>
<span class='rusttest'>macro_rules! o_O {
    (
        $(
            $x:expr; [ $( $y:expr ),* ]
        );*
    ) =&gt; {
        &amp;[ $($( $x + $y ),*),* ]
    }
}

fn main() {
    let a: &amp;[i32]
        = o_O!(10; [1, 2, 3];
               20; [4, 5, 6]);

    assert_eq!(a, [11, 12, 13, 24, 25, 26]);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>o_O</span> {
    (
        $(
            <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>; [ $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>y</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ]
        );<span class='op'>*</span>
    ) <span class='op'>=&gt;</span> {
        <span class='kw-2'>&amp;</span>[ $($( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span> <span class='op'>+</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>y</span> ),<span class='op'>*</span>),<span class='op'>*</span> ]
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>i32</span>]
        <span class='op'>=</span> <span class='macro'>o_O</span><span class='macro'>!</span>(<span class='number'>10</span>; [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
               <span class='number'>20</span>; [<span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>]);

    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>, [<span class='number'>11</span>, <span class='number'>12</span>, <span class='number'>13</span>, <span class='number'>24</span>, <span class='number'>25</span>, <span class='number'>26</span>]);
}</pre>

<p>Это наибольшая синтаксиса совпадений. Эти примеры используют конструкцию
<code>$(...)*</code>, которая означает «ноль или более» совпадений. Также вы можете
написать <code>$(...)+</code>, что будет означать «одно или более» совпадений. Обе формы
записи включают необязательный разделитель, располагающийся сразу за закрывающей
скобкой, который может быть любым символом, за исключением <code>+</code> или <code>*</code>.</p>

<p>Эта система повторений основана на
«<a href="http://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>» (PDF
ссылка).</p>

<h1 id='Гигиена-hygiene' class='section-header'><a href='#Гигиена-hygiene'>Гигиена (Hygiene)</a></h1>
<p>Некоторые языки реализуют макросы с помощью простой текстовой замены, что
приводит к различным проблемам. Например, нижеприведенная C программа напечатает
<code>13</code> вместо ожидаемого <code>25</code>.</p>

<pre><code class="language-text">#define FIVE_TIMES(x) 5 * x

int main() {
    printf(&quot;%d\n&quot;, FIVE_TIMES(2 + 3));
    return 0;
}
</code></pre>

<p>После развертывания мы получаем <code>5 * 2 + 3</code>, но умножение имеет больший
приоритет чем сложение. Если вы часто использовали C макросы, вы, наверное,
знаете стандартные идиомы для устранения этой проблемы, а также пять или шесть
других проблем. В Rust мы можем не беспокоиться об этом.</p>
<span class='rusttest'>macro_rules! five_times {
    ($x:expr) =&gt; (5 * $x);
}

fn main() {
    assert_eq!(25, five_times!(2 + 3));
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>five_times</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='number'>5</span> <span class='op'>*</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>25</span>, <span class='macro'>five_times</span><span class='macro'>!</span>(<span class='number'>2</span> <span class='op'>+</span> <span class='number'>3</span>));
}</pre>

<p>Метапеременная <code>$x</code> обрабатывается как единый узел выражения, и сохраняет свое
место в дереве синтаксиса даже после замены.</p>

<p>Другой распространенной проблемой в системе макросов является <em>захват
переменной</em> (<em>variable capture</em>). Вот C макрос, использующий <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">GNU C расширение</a>,
который эмулирует блоки выражениий в Rust.</p>

<pre><code class="language-text">#define LOG(msg) ({ \
    int state = get_log_state(); \
    if (state &gt; 0) { \
        printf(&quot;log(%d): %s\n&quot;, state, msg); \
    } \
})
</code></pre>

<p>Вот простой случай использования, применение которого может плохо кончиться:</p>

<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
LOG(state)
</code></pre>

<p>Он раскрывается в</p>

<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
int state = get_log_state();
if (state &gt; 0) {
    printf(&quot;log(%d): %s\n&quot;, state, state);
}
</code></pre>

<p>Вторая переменная с именем <code>state</code> затеняет первую. Это проблема, потому что
команде печати требуется обращаться к ним обоим.</p>

<p>Эквивалентный макрос в Rust обладает требуемым поведением.</p>
<span class='rusttest'>fn get_log_state() -&gt; i32 { 3 }
macro_rules! log {
    ($msg:expr) =&gt; {{
        let state: i32 = get_log_state();
        if state &gt; 0 {
            println!(&quot;log({}): {}&quot;, state, $msg);
        }
    }};
}

fn main() {
    let state: &amp;str = &quot;reticulating splines&quot;;
    log!(state);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>log</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>msg</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {{
        <span class='kw'>let</span> <span class='ident'>state</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>get_log_state</span>();
        <span class='kw'>if</span> <span class='ident'>state</span> <span class='op'>&gt;</span> <span class='number'>0</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;log({}): {}&quot;</span>, <span class='ident'>state</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>msg</span>);
        }
    }};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>state</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span> <span class='op'>=</span> <span class='string'>&quot;reticulating splines&quot;</span>;
    <span class='macro'>log</span><span class='macro'>!</span>(<span class='ident'>state</span>);
}</pre>

<p>Это работает, потому что Rust имеет <a href="http://en.wikipedia.org/wiki/Hygienic_macro">систему макросов с соблюдением
гигиены</a>. Раскрытие каждого макроса происходит в
отдельном <em>контексте синтаксиса</em>, и каждая переменная обладает меткой контекста
синтаксиса, где она была введена. Это как если бы переменная <code>state</code> внутри
<code>main</code> была бы окрашена в другой «цвет» в отличае от переменной <code>state</code> внутри
макроса, из-за чего они бы не конфликтовали.</p>

<p>Это также ограничивает возможности макросов для внедрения новых связываний
переменных на месте вызова. Код, приведенный ниже, не будет работать:</p>
<span class='rusttest'>macro_rules! foo {
    () =&gt; (let x = 3);
}

fn main() {
    foo!();
    println!(&quot;{}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> (<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>3</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<p>Вместо этого вы должны передавать имя переменной при вызове, тогда она будет
обладать меткой правильного контекста синтаксиса.</p>
<span class='rusttest'>macro_rules! foo {
    ($v:ident) =&gt; (let $v = 3);
}

fn main() {
    foo!(x);
    println!(&quot;{}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>v</span>:<span class='ident'>ident</span>) <span class='op'>=&gt;</span> (<span class='kw'>let</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>v</span> <span class='op'>=</span> <span class='number'>3</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>x</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<p>Это справедливо для <code>let</code> привязок и меток loop, но не для <a href="https://doc.rust-lang.org/stable/reference.html#items">элементов</a>.
Код, приведенный ниже, компилируется:</p>
<span class='rusttest'>macro_rules! foo {
    () =&gt; (fn x() { });
}

fn main() {
    foo!();
    x();
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> (<span class='kw'>fn</span> <span class='ident'>x</span>() { });
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>();
    <span class='ident'>x</span>();
}</pre>

<h1 id='Рекурсия-макросов' class='section-header'><a href='#Рекурсия-макросов'>Рекурсия макросов</a></h1>
<p>Раскрытие макроса также может включать в себя вызовы макросов, в том числе
вызовы того макроса, который раскрывается. Эти рекурсивные макросы могут быть
использованы для обработки древовидного ввода, как показано на этом (упрощенном)
HTML сокращение:</p>
<span class='rusttest'>#![allow(unused_must_use)]
macro_rules! write_html {
    ($w:expr, ) =&gt; (());

    ($w:expr, $e:tt) =&gt; (write!($w, &quot;{}&quot;, $e));

    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
        write!($w, &quot;&lt;{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($inner)*);
        write!($w, &quot;&lt;/{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($rest)*);
    }};
}

fn main() {
  // FIXME(#21826)
    use std::fmt::Write;
    let mut out = String::new();

    write_html!(&amp;mut out,
        html[
            head[title[&quot;Macros guide&quot;]]
            body[h1[&quot;Macros are the best!&quot;]]
        ]);

    assert_eq!(out,
        &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>write_html</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, ) <span class='op'>=&gt;</span> (());

    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>tt</span>) <span class='op'>=&gt;</span> (<span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;{}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));

    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>:<span class='ident'>ident</span> [ $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inner</span>:<span class='ident'>tt</span>)<span class='op'>*</span> ] $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {{
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;&lt;{}&gt;&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>));
        <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inner</span>)<span class='op'>*</span>);
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;&lt;/{}&gt;&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>));
        <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>)<span class='op'>*</span>);
    }};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Write</span>;
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>out</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>out</span>,
        <span class='ident'>html</span>[
            <span class='ident'>head</span>[<span class='ident'>title</span>[<span class='string'>&quot;Macros guide&quot;</span>]]
            <span class='ident'>body</span>[<span class='ident'>h1</span>[<span class='string'>&quot;Macros are the best!&quot;</span>]]
        ]);

    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>out</span>,
        <span class='string'>&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);
}</pre>

<p><a name="debugging-macro-code"></a></p>

<h1 id='Отладка-макросов' class='section-header'><a href='#Отладка-макросов'>Отладка макросов</a></h1>
<p>Чтобы увидеть результаты расширения макросов, выполните команду <code>rustc --pretty expanded</code>. Вывод представляет собой целый контейнер, так что вы можете подать
его обратно в <code>rustc</code>, что иногда выдает лучшие сообщения об ошибках, чем при
обычной компиляции. Обратите внимание, что вывод <code>--pretty expanded</code> может иметь
разное значение, если несколько переменных, имеющих одно и то же имя (но разные
контексты синтаксиса), находятся в той же области видимости. В этом случае
<code>--pretty expanded,hygiene</code> расскажет вам о контекстах синтаксиса.</p>

<p><code>rustc</code>, поддерживает два синтаксических расширения, которые помогают с отладкой
макросов. В настоящее время, они неустойчивы и требуют feature gates.</p>

<ul>
<li><p><code>log_syntax!(...)</code> будет печатать свои аргументы в стандартный вывод во время
компиляции, и «развертываться» в ничто.</p></li>
<li><p><code>trace_macros!(true)</code> будет выдавать сообщение компилятора каждый раз, когда
макрос развертывается. Используйте <code>trace_macros!(false)</code> в конце развертывания,
чтобы выключить его.</p></li>
</ul>

<h1 id='Требования-синтаксиса' class='section-header'><a href='#Требования-синтаксиса'>Требования синтаксиса</a></h1>
<p>Код на Rust может быть разобран в <a href="glossary.html#abstract-syntax-tree">синтаксическое дерево</a>, даже когда он
содержит неразвёрнутые макросы. Это свойство очень полезно для редакторов и
других инструментов, обрабатывающих исходный код. Оно также влияет на вид
системы макросов Rust.</p>

<p>Как следствие, когда компилятор разбирает вызов макроса, ему необходимо знать,
во что развернётся данный макрос. Макрос может разворачиваться в следующее:</p>

<ul>
<li>ноль или больше элементов;</li>
<li>ноль или больше методов;</li>
<li>выражение;</li>
<li>оператор;</li>
<li>образец.</li>
</ul>

<p>Вызов макроса в блоке может представлять собой элементы, выражение, или
оператор. Rust использует простое правило для разрешения этой
неоднозначности. Вызов макроса, производящего элементы, должен либо</p>

<ul>
<li>ограничиваться фигурными скобками, т.е. <code>foo! { ... }</code>;</li>
<li>завершаться точкой с запятой, т.е. <code>foo!(...);</code>.</li>
</ul>

<p>Другое следствие разбора перед раскрытием макросов — это то, что вызов макроса
должен состоять из допустимых лексем. Более того, скобки всех видов должны быть
сбалансированы в месте вызова. Например, <code>foo!([)</code> не является разрешённым
кодом. Такое поведение позволяет компилятору понимать где заканчивается вызов
макроса.</p>

<p>Говоря более формально, тело вызова макроса должно представлять собой
последовательность <em>деревьев лексем</em>. Дерево лексем определяется рекурсивно и
представляет собой либо:</p>

<ul>
<li>последовательность деревьев лексем, окружённую согласованными круглыми,
квадратными или фигурными скобками (<code>()</code>, <code>[]</code>, <code>{}</code>);</li>
<li>любую другую одиночную лексему.</li>
</ul>

<p>Внутри сопоставления каждая метапеременная имеет <em>указатель фрагмента</em>,
определяющий синтаксическую форму, с которой она совпадает. Вот список этих
указателей:</p>

<ul>
<li><code>ident</code>: идентификатор. Например: <code>x</code>; <code>foo</code>.</li>
<li><code>path</code>: квалифицированное имя. Например: <code>T::SpecialA</code>.</li>
<li><code>expr</code>: выражение. Например: <code>2 + 2</code>; <code>if true then { 1 } else { 2 }</code>;
<code>f(42)</code>.</li>
<li><code>ty</code>: тип. Например: <code>i32</code>; <code>Vec&lt;(char, String)&gt;</code>; <code>&amp;T</code>.</li>
<li><code>pat</code>: образец. Например: <code>Some(t)</code>; <code>(17, &#39;a&#39;)</code>; <code>_</code>.</li>
<li><code>stmt</code>: единственный оператор. Например: <code>let x = 3</code>.</li>
<li><code>block</code>: последовательность операторов, ограниченная фигурными
скобками. Например: <code>{ log(error, &quot;hi&quot;); return 12; }</code>.</li>
<li><code>item</code>: <a href="http://doc.rust-lang.org/reference.html#items">элемент</a>. Например: <code>fn foo() { }</code>; <code>struct Bar;</code>.</li>
<li><code>meta</code>: «мета-элемент», как в атрибутах. Например: <code>cfg(target_os = &quot;windows&quot;)</code>.</li>
<li><code>tt</code>: единственное дерево лексем.</li>
</ul>

<p>Есть дополнительные правила относительно лексем, следующих за метапеременной:</p>

<ul>
<li>за <code>expr</code> должно быть что-то из этого: <code>=&gt; , ;</code>;</li>
<li>за <code>ty</code> и <code>path</code> должно быть что-то из этого: <code>=&gt; , : = &gt; as</code>;</li>
<li>за <code>pat</code> должно быть что-то из этого : <code>=&gt; , =</code>;</li>
<li>за другими лексемами могут следовать любые символы.</li>
</ul>

<p>Приведённые правила обеспечивают развитие синтаксиса Rust без необходимости
менять существующие макросы.</p>

<p>И ещё: система макросов никак не обрабатывет неоднозначность разбора. Например,
грамматика <code>$($t:ty)* $e:expr</code> всегда будет выдавать ошибку, потому что
синтаксическому анализатору пришлось бы выбирать между разбором <code>$t</code> и разбором
<code>$e</code>. Можно изменить синтаксис вызова так, чтобы грамматика отличалась в начале.
В данном случае можно написать <code>$(T $t:ty)* E $e:exp</code>.</p>

<h1 id='Области-видимости-импорт-и-экспорт-макросов' class='section-header'><a href='#Области-видимости-импорт-и-экспорт-макросов'>Области видимости, импорт и экспорт макросов</a></h1>
<p>Макросы разворачиваются на ранней стадии компиляции, перед разрешением имён.
Один из недостатков такого подхода в том, что правила видимости для макросов
отличны от правил для других конструкций языка.</p>

<p>Компилятор определяет и разворачивает макросы при обходе графа исходного кода
контейнера в глубину. При этом определения макросов включаются в граф в порядке
их встречи компилятором. Поэтому макрос, определённый на уровне модуля, виден во
всём последующем коде модуля, включая тела всех вложенных модулей (<code>mod</code>).</p>

<p>Макрос, определённый в теле функции, или где-то ещё не на уровне модуля, виден
только внутри этого элемента (например, внутри одной функции).</p>

<p>Если модуль имеет атрибут <code>macro_use</code>, то его макросы также видны в его
родительском модуле после элемента <code>mod</code> данного модуля. Если родитель тоже
имеет атрибут <code>macro_use</code>, макросы также будут видны в модуле-родителе родителя,
после элемента <code>mod</code> родителя. Это распространяется на любое число уровней.</p>

<p>Атрибут <code>macro_use</code> также можно поставить на подключение контейнера <code>extern crate</code>. В этом контексте оно управляет тем, какие макросы будут загружены из
внешнего контейнера, т.е.</p>
<span class='rusttest'>fn main() {
    #[macro_use(foo, bar)]
    extern crate baz;
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_use</span>(<span class='ident'>foo</span>, <span class='ident'>bar</span>)]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>baz</span>;</pre>

<p>Если атрибут записан просто как <code>#[macro_use]</code>, будут загружены все
макросы. Если атрибута нет, никакие макросы не будут загружены. Загружены могут
быть только макросы, объявленные с атрибутом <code>#[macro_export]</code>.</p>

<p>Чтобы загрузить макросы из контейнера <em>без</em> компоновки контейнера в выходной
артефакт, можно использовать атрибут <code>#[no_link]</code>.</p>

<p>Например:</p>
<span class='rusttest'>macro_rules! m1 { () =&gt; (()) }

// здесь видны: m1

mod foo {
    // здесь видны: m1

    #[macro_export]
    macro_rules! m2 { () =&gt; (()) }

    // здесь видны: m1, m2
}

// здесь видны: m1

macro_rules! m3 { () =&gt; (()) }

// здесь видны: m1, m3

#[macro_use]
mod bar {
    // здесь видны: m1, m3

    macro_rules! m4 { () =&gt; (()) }

    // здесь видны: m1, m3, m4
}

// здесь видны: m1, m3, m4
fn main() { }
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m1</span> { () <span class='op'>=&gt;</span> (()) }

<span class='comment'>// здесь видны: m1</span>

<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='comment'>// здесь видны: m1</span>

    <span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m2</span> { () <span class='op'>=&gt;</span> (()) }

    <span class='comment'>// здесь видны: m1, m2</span>
}

<span class='comment'>// здесь видны: m1</span>

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m3</span> { () <span class='op'>=&gt;</span> (()) }

<span class='comment'>// здесь видны: m1, m3</span>

<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>mod</span> <span class='ident'>bar</span> {
    <span class='comment'>// здесь видны: m1, m3</span>

    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m4</span> { () <span class='op'>=&gt;</span> (()) }

    <span class='comment'>// здесь видны: m1, m3, m4</span>
}

<span class='comment'>// здесь видны: m1, m3, m4</span></pre>

<p>Когда эта библиотека загружается с помощью <code>#[macro_use] extern crate</code>, виден
только макрос <code>m2</code>.</p>

<p>Атрибуты, относящиеся к макросам,
<a href="https://doc.rust-lang.org/stable/reference.html#macro--and-plugin-related-attributes">перечислены в справочнике Rust</a>.</p>

<h1 id='Переменная-crate' class='section-header'><a href='#Переменная-crate'>Переменная <code>$crate</code></a></h1>
<p>Если макрос используется в нескольких контейнерах, всё становится ещё
сложнее. Допустим, <code>mylib</code> определяет</p>
<span class='rusttest'>pub fn increment(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc_a {
    ($x:expr) =&gt; ( ::increment($x) )
}

#[macro_export]
macro_rules! inc_b {
    ($x:expr) =&gt; ( ::mylib::increment($x) )
}
fn main() { }
</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>increment</span>(<span class='ident'>x</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}

<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc_a</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( ::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}

<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc_b</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( ::<span class='ident'>mylib</span>::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}</pre>

<p><code>inc_a</code> работает только внутри <code>mylib</code>, а <code>inc_b</code> — только снаружи. Более того,
<code>inc_b</code> сломается, если пользователь импортирует <code>mylib</code> под другим именем.</p>

<p>В Rust пока нет гигиеничных ссылок на контейнеры, но есть простой способ обойти
эту проблему. Особая макро-переменная <code>$crate</code> раскроется в <code>::foo</code> внутри
макроса, импортированного из контейнера <code>foo</code>. А когда макрос определён и
используется в одном и том же контейнере, <code>$crate</code> станет пустой. Это означает,
что мы можем написать</p>
<span class='rusttest'>#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
fn main() { }
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>crate</span>::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}</pre>

<p>чтобы определить один макрос, который будет работать и внутри, и снаружи
библиотеки. Имя функции раскроется или в <code>::increment</code>, или в
<code>::mylib::increment</code>.</p>

<p>Чтобы эта система работала просто и правильно, <code>#[macro_use] extern crate ...</code>
может быть написано только в корне вашего контейнера, но не внутри <code>mod</code>. Это
обеспечивает, что <code>$crate</code> раскроется в единственный идентификатор.</p>

<h1 id='Во-тьме-глубин' class='section-header'><a href='#Во-тьме-глубин'>Во тьме глубин</a></h1>
<p>Вводная глава упоминала рекурсивные макросы, но она не рассказывала всей
истории. Рекурсивные макросы полезны ещё по одной причине: каждый рекурсивный
вызов даёт нам ещё одну возможность сопоставить с образцом аргументы макроса.</p>

<p>Приведём такой радикальный пример использования данной возможности. С помощью
рекурсивных макросов можно реализовать конечный автомат типа
<a href="http://esolangs.org/wiki/Bitwise_Cyclic_Tag">Bitwise Cyclic Tag</a>. Стоит
заметить, что мы не рекомендуем такой подход, а просто иллюстрируем возможности
макросов.</p>
<span class='rusttest'>fn main() {
    macro_rules! bct {
        // cmd 0:  d ... =&gt; ...
        (0, $($ps:tt),* ; $_d:tt)
            =&gt; (bct!($($ps),*, 0 ; ));
        (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
            =&gt; (bct!($($ps),*, 0 ; $($ds),*));
    
        // cmd 1p:  1 ... =&gt; 1 ... p
        (1, $p:tt, $($ps:tt),* ; 1)
            =&gt; (bct!($($ps),*, 1, $p ; 1, $p));
        (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)
            =&gt; (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));
    
        // cmd 1p:  0 ... =&gt; 0 ...
        (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)
            =&gt; (bct!($($ps),*, 1, $p ; $($ds),*));
    
        // halt on empty data string
        ( $($ps:tt),* ; )
            =&gt; (());
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>bct</span> {
    <span class='comment'>// cmd 0:  d ... =&gt; ...</span>
    (<span class='number'>0</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_d</span>:<span class='ident'>tt</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>0</span> ; ));
    (<span class='number'>0</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_d</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='op'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>0</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='op'>*</span>));

    <span class='comment'>// cmd 1p:  1 ... =&gt; 1 ... p</span>
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='number'>1</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>));
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='number'>1</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='op'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; <span class='number'>1</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='op'>*</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>));

    <span class='comment'>// cmd 1p:  0 ... =&gt; 0 ...</span>
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='op'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='op'>*</span>));

    <span class='comment'>// halt on empty data string</span>
    ( $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; )
        <span class='op'>=&gt;</span> (());
}</pre>

<p>В качестве упражнения предлагаем читателю определить ещё один макрос, чтобы
уменьшить степень дублирования кода в определении выше.</p>

<h1 id='Распространённые-макросы' class='section-header'><a href='#Распространённые-макросы'>Распространённые макросы</a></h1>
<p>Вот некоторые распространённые макросы, которые вы увидите в коде на Rust.</p>

<h2 id='panic' class='section-header'><a href='#panic'>panic!</a></h2>
<p>Этот макрос вызывает панику текущего потока. Вы можете указать сообщение, с
которым поток завершится:</p>
<span class='rusttest'>fn main() {
    panic!(&quot;о нет!&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;о нет!&quot;</span>);</pre>

<h2 id='vec' class='section-header'><a href='#vec'>vec!</a></h2>
<p>Макрос <code>vec!</code> используется по всей книге, поэтому вы наверняка уже видели его.
Он упрощает создание <code>Vec&lt;T&gt;</code>:</p>
<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3, 4, 5];
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];</pre>

<p>Он также позволяет вам создавать векторы с повторяющимися значениями. Например,
вот сто нолей:</p>
<span class='rusttest'>fn main() {
    let v = vec![0; 100];
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>0</span>; <span class='number'>100</span>];</pre>

<h2 id='assert-and-assert_eq' class='section-header'><a href='#assert-and-assert_eq'>assert! and assert_eq!</a></h2>
<p>Эти два макроса используются в тестах. <code>assert!</code> принимает логическое значение.
<code>assert_eq!</code> принимает два значения и проверяет, что они равны. <code>true</code>
засчитывается как успех, а <code>false</code> вызывает панику и проваливает тест. Вот так:</p>
<span class='rusttest'>fn main() {
    // Работает!
    
    assert!(true);
    assert_eq!(5, 3 + 2);
    
    // а это нет :(
    
    assert!(5 &lt; 3);
    assert_eq!(5, 3);
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// Работает!</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='boolval'>true</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='number'>3</span> <span class='op'>+</span> <span class='number'>2</span>);

<span class='comment'>// а это нет :(</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='number'>5</span> <span class='op'>&lt;</span> <span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='number'>3</span>);</pre>

<h2 id='try' class='section-header'><a href='#try'>try!</a></h2>
<p><code>try!</code> используется для обработки ошибок. Он принимает нечто возвращающее
<code>Result&lt;T, E&gt;</code> и возвращает <code>T</code> если было возвращено <code>Ok&lt;T&gt;</code>; иначе он делает
возврат из функции со значением <code>Err(E)</code>. Вроде такого:</p>
<span class='rusttest'>fn main() {
    use std::fs::File;
    
    fn foo() -&gt; std::io::Result&lt;()&gt; {
        let f = try!(File::create(&quot;foo.txt&quot;));
    
        Ok(())
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;foo.txt&quot;</span>));

    <span class='prelude-val'>Ok</span>(())
}</pre>

<p>Такой код читается легче, чем этот:</p>
<span class='rusttest'>fn main() {
    use std::fs::File;
    
    fn foo() -&gt; std::io::Result&lt;()&gt; {
        let f = File::create(&quot;foo.txt&quot;);
    
        let f = match f {
            Ok(t) =&gt; t,
            Err(e) =&gt; return Err(e),
        };
    
        Ok(())
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;foo.txt&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>f</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>t</span>) <span class='op'>=&gt;</span> <span class='ident'>t</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>),
    };

    <span class='prelude-val'>Ok</span>(())
}</pre>

<h2 id='unreachable' class='section-header'><a href='#unreachable'>unreachable!</a></h2>
<p>Этот макрос применяется, когда вы хотите пометить какой-то код, который никогда
не должен исполняться:</p>
<span class='rusttest'>fn main() {
    if false {
        unreachable!();
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>if</span> <span class='boolval'>false</span> {
    <span class='macro'>unreachable</span><span class='macro'>!</span>();
}</pre>

<p>Иногда вам придётся определять ветви условных конструкций, которые точно никогда
не исполнятся. В таком случае, используйте этот макрос, чтобы в случае ошибки
программа запаниковала:</p>
<span class='rusttest'>fn main() {
    let x: Option&lt;i32&gt; = None;
    
    match x {
        Some(_) =&gt; unreachable!(),
        None =&gt; println!(&quot;Я знаю, что x — это None!&quot;),
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-val'>None</span>;

<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='prelude-val'>Some</span>(_) <span class='op'>=&gt;</span> <span class='macro'>unreachable</span><span class='macro'>!</span>(),
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Я знаю, что x — это None!&quot;</span>),
}</pre>

<h2 id='unimplemented' class='section-header'><a href='#unimplemented'>unimplemented!</a></h2>
<p>Макрос <code>unimplemented!</code> можно использовать, когда вы хотите, чтобы ваш код
прошёл проверку типов, но пока не хотите реализовывать его настоящую логику.
Один из примеров — это реализация типажа с несколькими требуемыми методами.
Возможно, вы хотите разбираться с типажом постепенно — по одному методу за раз.
В таком случае, определите остальные методы как <code>unimplemented!</code>, пока не
захотите наконец реализовать их.</p>

<h1 id='Процедурные-макросы' class='section-header'><a href='#Процедурные-макросы'>Процедурные макросы</a></h1>
<p>Если система макросов не может сделать того, что вам нужно, вы можете написать
<a href="compiler-plugins.html">плагин к компилятору</a>. По сравнению с макросами, это гораздо
труднее, там ещё более нестабильные интерфейсы, и ещё сложнее найти ошибки. Зато
вы получаете гибкость — внутри плагина может исполняться произвольный код на
Rust. Иногда плагины расширения синтаксиса называются <em>процедурными макросами</em>.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Фактическое определение <code>vec!</code> в libcollections отличается от&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>