<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Трейт объекты</title>

    <link rel="stylesheet" type="text/css" href="../rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='../src/README.html'><b>2.</b> Введение</a>
</li>
<li><a href='../src/getting-started.html'><b>3.</b> C чего начать</a>
<ul class='section'>
<li><a href='../src/installing-rust.html'><b>3.1.</b> Установка Rust</a>
</li>
<li><a href='../src/hello-world.html'><b>3.2.</b> Hello, world!</a>
</li>
<li><a href='../src/hello-cargo.html'><b>3.3.</b> Hello, Cargo!</a>
</li>
</ul>
</li>
<li><a href='../src/learn-rust.html'><b>4.</b> Изучение Rust</a>
<ul class='section'>
<li><a href='../src/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
<li><a href='../src/dining-philosophers.html'><b>4.2.</b> Обедающие философы</a>
</li>
<li><a href='../src/rust-inside-other-languages.html'><b>4.3.</b> Вызов кода на Rust из других языков</a>
</li>
</ul>
</li>
<li><a href='../src/effective-rust.html'><b>5.</b> Эффективное использование Rust</a>
<ul class='section'>
<li><a href='../src/the-stack-and-the-heap.html'><b>5.1.</b> Стек и Куча</a>
</li>
<li><a href='../src/testing.html'><b>5.2.</b> Тестирование</a>
</li>
<li><a href='../src/conditional-compilation.html'><b>5.3.</b> Условная компиляция</a>
</li>
<li><a href='../src/documentation.html'><b>5.4.</b> Документация</a>
</li>
<li><a href='../src/iterators.html'><b>5.5.</b> Итераторы</a>
</li>
<li><a href='../src/concurrency.html'><b>5.6.</b> Многозадачность</a>
</li>
<li><a href='../src/error-handling.html'><b>5.7.</b> Обработка ошибок</a>
</li>
<li><a href='../src/ffi.html'><b>5.8.</b> Интерфейс внешних функций (FFI)</a>
</li>
<li><a href='../src/release-channels.html'><b>5.9.</b> Каналы сборок</a>
</li>
</ul>
</li>
<li><a href='../src/syntax-and-semantics.html'><b>6.</b> Синтаксис и семантика</a>
<ul class='section'>
<li><a href='../src/variable-bindings.html'><b>6.1.</b> Связывание переменных</a>
</li>
<li><a href='../src/functions.html'><b>6.2.</b> Функции</a>
</li>
<li><a href='../src/primitive-types.html'><b>6.3.</b> Простые типы</a>
</li>
<li><a href='../src/comments.html'><b>6.4.</b> Комментарии</a>
</li>
<li><a href='../src/if.html'><b>6.5.</b> Конструкция `if`</a>
</li>
<li><a href='../src/for-loops.html'><b>6.6.</b> Циклы `for`</a>
</li>
<li><a href='../src/while-loops.html'><b>6.7.</b> Циклы `while`</a>
</li>
<li><a href='../src/ownership.html'><b>6.8.</b> Владение</a>
</li>
<li><a href='../src/references-and-borrowing.html'><b>6.9.</b> Ссылки и Заимствование</a>
</li>
<li><a href='../src/lifetimes.html'><b>6.10.</b> Время жизни</a>
</li>
<li><a href='../src/mutability.html'><b>6.11.</b> Изменяемость (Мутабельность)</a>
</li>
<li><a href='../src/enums.html'><b>6.12.</b> Перечисления</a>
</li>
<li><a href='../src/match.html'><b>6.13.</b> Конструкция `match`</a>
</li>
<li><a href='../src/structs.html'><b>6.14.</b> Структуры</a>
</li>
<li><a href='../src/patterns.html'><b>6.15.</b> Шаблоны `match`</a>
</li>
<li><a href='../src/method-syntax.html'><b>6.16.</b> Синтаксис методов</a>
</li>
<li><a href='../src/vectors.html'><b>6.17.</b> Вектора</a>
</li>
<li><a href='../src/strings.html'><b>6.18.</b> Строки</a>
</li>
<li><a href='../src/generics.html'><b>6.19.</b> Дженерики</a>
</li>
<li><a href='../src/traits.html'><b>6.20.</b> Трейты</a>
</li>
<li><a href='../src/drop.html'><b>6.21.</b> Трейт `Drop`</a>
</li>
<li><a href='../src/if-let.html'><b>6.22.</b> Конструкция `if let`</a>
</li>
<li><a href='../src/trait-objects.html'><b>6.23.</b> Трейт объекты</a>
</li>
<li><a href='../src/closures.html'><b>6.24.</b> Замыкания</a>
</li>
<li><a href='../src/ufcs.html'><b>6.25.</b> Универсальный синтаксис вызова функций (UFCS)</a>
</li>
<li><a href='../src/crates-and-modules.html'><b>6.26.</b> Контейнеры и Модули</a>
</li>
<li><a href='../src/const-and-static.html'><b>6.27.</b> `const` и `static`</a>
</li>
<li><a href='../src/tuple-structs.html'><b>6.28.</b> Кортежные структуры</a>
</li>
<li><a href='../src/attributes.html'><b>6.29.</b> Атрибуты</a>
</li>
<li><a href='../src/type-aliases.html'><b>6.30.</b> Псевдонимы типов</a>
</li>
<li><a href='../src/casting-between-types.html'><b>6.31.</b> Преобразование типов</a>
</li>
<li><a href='../src/associated-types.html'><b>6.32.</b> Ассоциированные типы</a>
</li>
<li><a href='../src/unsized-types.html'><b>6.33.</b> Безразмерные типы</a>
</li>
<li><a href='../src/operators-and-overloading.html'><b>6.34.</b> Operators and Overloading</a>
</li>
<li><a href='../src/deref-coercions.html'><b>6.35.</b> Трейт `Deref`</a>
</li>
<li><a href='../src/macros.html'><b>6.36.</b> Макросы</a>
</li>
<li><a href='../src/raw-pointers.html'><b>6.37.</b> Сырые указатели</a>
</li>
<li><a href='../src/unsafe.html'><b>6.38.</b> `unsafe` код</a>
</li>
</ul>
</li>
<li><a href='../src/nightly-rust.html'><b>7.</b> Нестабильные фичи Rust</a>
<ul class='section'>
<li><a href='../src/compiler-plugins.html'><b>7.1.</b> Плагины компилятора</a>
</li>
<li><a href='../src/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a href='../src/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a href='../src/intrinsics.html'><b>7.4.</b> Внутренние средства</a>
</li>
<li><a href='../src/lang-items.html'><b>7.5.</b> Lang items</a>
</li>
<li><a href='../src/link-args.html'><b>7.6.</b> Аргументы линковки</a>
</li>
<li><a href='../src/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a href='../src/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a href='../src/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a href='../src/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
</ul>
</li>
<li><a href='../src/glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a href='../src/academic-research.html'><b>9.</b> Академические исследования</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Трейт объекты</h1>
    <p>Когда код включает в себя полиморфизм, то должен быть механизм, чтобы
определить, какая конкретная версия будет фактически вызвана. Это называется
&#39;диспетчерезация.&#39; Есть две основные формы диспетчерезации: статическая и
динамическая. Хотя Rust и отдает предпочтение статической диспетчерезации, он
также поддерживает динамическую диспетчерезацию через механизм, называемый
&#39;трейт объекты.&#39;</p>

<h2 id="Подготовка" class='section-header'><a
                           href="#Подготовка">Подготовка</a></h2>
<p>Для остальной части этой главы нам потребуется трейт и несколько его реализаций.
Давайте создадим простой трейт <code>Foo</code>. Он содержит один метод, который возвращает
<code>String</code>.</p>
<span class='rusttest'>fn main() {
    trait Foo {
        fn method(&amp;self) -&gt; String;
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span>;
}
</pre>

<p>Также мы реализуем этот трейт для <code>u8</code> и <code>String</code>:</p>
<span class='rusttest'>fn main() {
    trait Foo { fn method(&amp;self) -&gt; String; }
    impl Foo for u8 {
        fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) }
    }
    
    impl Foo for String {
        fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>u8</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span> { <span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;u8: {}&quot;</span>, <span class='op'>*</span><span class='self'>self</span>) }
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>String</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span> { <span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;string: {}&quot;</span>, <span class='op'>*</span><span class='self'>self</span>) }
}
</pre>

<h2 id="Статическая-диспетчерезация" class='section-header'><a
                           href="#Статическая-диспетчерезация">Статическая диспетчерезация</a></h2>
<p>Мы можем использовать этот трейт для выполнения статической диспетчерезации с
помощью ограничения трейтом:</p>
<span class='rusttest'>trait Foo { fn method(&amp;self) -&gt; String; }
impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }
fn do_something&lt;T: Foo&gt;(x: T) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = &quot;Hello&quot;.to_string();

    do_something(x);
    do_something(y);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>do_something</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u8</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();

    <span class='ident'>do_something</span>(<span class='ident'>x</span>);
    <span class='ident'>do_something</span>(<span class='ident'>y</span>);
}
</pre>

<p>Здесь Rust использует &#39;мономорфизацию&#39; для статической диспетчерезации. Это
означает, что Rust создаст специальную версию <code>do_something()</code> для каждого из
типов: <code>u8</code> и <code>String</code>, а затем заменит все места вызовов на вызовы этих
специализированных функций. Другими словами, Rust сгенерирует нечто вроде этого:</p>
<span class='rusttest'>trait Foo { fn method(&amp;self) -&gt; String; }
impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }
fn do_something_u8(x: u8) {
    x.method();
}

fn do_something_string(x: String) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = &quot;Hello&quot;.to_string();

    do_something_u8(x);
    do_something_string(y);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>do_something_u8</span>(<span class='ident'>x</span>: <span class='ident'>u8</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>do_something_string</span>(<span class='ident'>x</span>: <span class='ident'>String</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u8</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();

    <span class='ident'>do_something_u8</span>(<span class='ident'>x</span>);
    <span class='ident'>do_something_string</span>(<span class='ident'>y</span>);
}
</pre>

<p>Статическая диспетчерезация имеет большой потенциал: она позволяет вызывать
функцию, которая будет встроена, потому что вызываемая версия этой функции
известна на этапе компиляции, а встраивание - это ключ к хорошей оптимизации.
Статическая диспетчерезация быстра, но это достигается путем компромисса:
происходит &#39;раздувание кода&#39; в связи с большим количеством копий одной и той же
функции, по одной для каждого типа, расположенных в бинарном файле.</p>

<p>Кроме того, компиляторы не совершенны и могут &quot;оптимизировать&quot; код так, что он
станет медленнее. Например, встроенные функции будут слишком охотно раздувать
кэш команд (правила кэширования все вокруг нас). Это одна из причин, по которой
<code>#[inline]</code> и <code>#[inline(always)]</code> следует использовать осторожно, и почему
использование динамической диспетчеризации иногда более эффективно.</p>

<p>Тем не менее, в общем случае более эффективно использовать статическую
диспетчерезацию. Кроме того, всегда можно иметь тонкую статически-
диспетчерезуемую обертку для функции, которая выполняет динамическую
диспетчеризацию, но не наоборот. То есть статические вызовы являются более
гибкими. По этой причине стандартная библиотека старается быть статически
диспетчерезуемой везде, где это возможно.</p>

<h2 id="Динамическая-диспетчерезация" class='section-header'><a
                           href="#Динамическая-диспетчерезация">Динамическая диспетчерезация</a></h2>
<p>Rust обеспечивает динамическую диспетчеризацию через механизм под названием
&#39;трейт объекты.&#39; Трейт объекты, такие как <code>&amp;Foo</code> или <code>Box&lt;Foo&gt;</code>, это обычные
переменные, хранящие значения <em>любого</em> типа, реализующего данный трейт.
Конкретный тип трейт объекта может быть определен только на этапе выполнения.</p>

<p>Трейт объект может быть получен из указателя на конкретный тип, который
реализует этот трейт, путем его <code>явного приведения</code> (например, <code>&amp;x as &amp;Foo</code>) или
<code>неявного приведения</code> (например, используя <code>&amp;x</code> в качестве аргумента функции,
которая принимает <code>&amp;Foo</code>).</p>

<p>Явное и неявное приведение трейт объекта также работает для таких указателей,
как <code>&amp;mut T</code> в <code>&amp;mut Foo</code> и <code>Box&lt;T&gt;</code> в <code>Box&lt;Foo&gt;</code>, но это все на данный момент.
Явное и неявное приведение идентичны.</p>

<p>Эта операция может рассматриваться как &quot;затирание&quot; знания компилятора о
конкретном типе указателя, поэтому трейт объекты иногда называют как &quot;затирание
типов&quot;.</p>

<p>Возвращаясь к примеру выше, мы можем использовать тот же самый трейт для
выполнения динамической диспетчеризации с трейт объектами путем явного
приведения типа:</p>
<span class='rusttest'>trait Foo { fn method(&amp;self) -&gt; String; }
impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }

fn do_something(x: &amp;Foo) {
    x.method();
}

fn main() {
    let x = 5u8;
    do_something(&amp;x as &amp;Foo);
}
</span><pre class='rust rust-example-rendered'>

<span class='kw'>fn</span> <span class='ident'>do_something</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u8</span>;
    <span class='ident'>do_something</span>(<span class='kw-2'>&amp;</span><span class='ident'>x</span> <span class='kw'>as</span> <span class='kw-2'>&amp;</span><span class='ident'>Foo</span>);
}
</pre>

<p>или неявного приведения типа:</p>
<span class='rusttest'>trait Foo { fn method(&amp;self) -&gt; String; }
impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }

fn do_something(x: &amp;Foo) {
    x.method();
}

fn main() {
    let x = &quot;Hello&quot;.to_string();
    do_something(&amp;x);
}
</span><pre class='rust rust-example-rendered'>

<span class='kw'>fn</span> <span class='ident'>do_something</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();
    <span class='ident'>do_something</span>(<span class='kw-2'>&amp;</span><span class='ident'>x</span>);
}
</pre>

<p>Функция, которая принимает трейт объект, не обладает специализированнми копиями
для каждого из типов, которые реализуют трейт <code>Foo</code>: генерируется только одна
копия. Часто (но не всегда), в результате происходит уменьшение раздувания кода.
Тем не менее, это происходит за счет более медленного вызова виртуальных
функций, и, по существу, блокирования любой возможности встраивания и связанных
с этим оптимизаций.</p>

<h3 id="Почему-указатели?" class='section-header'><a
                           href="#Почему-указатели?">Почему указатели?</a></h3>
<p>В отличие от многих управляемых языков, Rust по умолчанию не размещает значения
по указателю, так как типы могут иметь различные размеры. Знать размер значения
во время компиляции важно прежде всего для выполнения таких задач, как передача
значения в качестве аргумента в функцию, что вызывает помещение переданного
значения в стек, и выделение (и освобождение) места на куче для сохранения
значения там.</p>

<p>Для <code>Foo</code> допускается иметь значение, которое может быть либо <code>String</code> (24
байт), либо <code>u8</code> (1 байт), либо любой другой тип, для которого в соответствующих
крейтах может быть реализован <code>Foo</code> (возможно абсолютно любое число байт). Так
как этот другой тип может быть сколь угодно большими, то нет никакого способа,
гарантирующего, что последний вариант будет работать, если значения сохраняются
без указателя.</p>

<p>Размещение значения по указателю означает, что, когда мы имеем дело с трейт
объектом, размер самого значения не важен, а важен лишь размер указателя.</p>

<h3 id="representation-Представление" class='section-header'><a
                           href="#representation-Представление">Representation Представление</a></h3>
<p>Методы трейта можно вызвать для трейт объекта с помощью специальной записи
указателей на функции, традиционно называемой &#39;виртуальная таблица&#39; (&#39;vtable&#39;)
(создается и управляется компилятором).</p>

<p>Трейт объекты являются одновременно и простыми и сложными: их основное
представление и устройство довольно прямолинейно, но есть некоторые тонкости
относительно обнаружения сообщений об ошибках и странного поведения.</p>

<p>Давайте начнем с простого, с рантайм представления трейт объекта. Модуль
<code>std::raw</code> содержит структуры с макетами, которые являются такими же, как и
сложные встроенные типы, <a href="http://doc.rust-lang.org/std/raw/struct.TraitObject.html">в том числе трейт объекты</a>:</p>
<span class='rusttest'>fn main() {
    mod foo {
    pub struct TraitObject {
        pub data: *mut (),
        pub vtable: *mut (),
    }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>TraitObject</span> {
    <span class='kw'>pub</span> <span class='ident'>data</span>: <span class='op'>*</span><span class='kw-2'>mut</span> (),
    <span class='kw'>pub</span> <span class='ident'>vtable</span>: <span class='op'>*</span><span class='kw-2'>mut</span> (),
}
</pre>

<p>То есть трейт объект, такой как <code>&amp;Foo</code>, состоит из указателя на &quot;данные&quot; и
указателя на &quot;виртуальную таблицу&quot;.</p>

<p>Указатель <code>data</code> адрессует данные (какого-то неизвестного типа <code>T</code>), которые
хранит трейт объект, а указатель <code>vtable</code> указывает на виртуальную таблицу
(&quot;таблица виртуальных методов&quot;), которая соответствует реализации <code>Foo</code> для <code>T</code>.</p>

<p>По существу, виртуальная таблица - это структура указателей на функции,
указывающих на конкретный кусок машинного кода для каждого метода в реализации.
Вызов метода наподобие <code>trait_object.method()</code> возвращает правильный указатель
из виртуальной таблицы, а затем динамически вызывает метод по этому указателю.
Например:</p>
<span class='rusttest'>fn main() {
    struct FooVtable {
        destructor: fn(*mut ()),
        size: usize,
        align: usize,
        method: fn(*const ()) -&gt; String,
    }
    
    // u8:
    
    fn call_method_on_u8(x: *const ()) -&gt; String {
        // the compiler guarantees that this function is only called
        // with `x` pointing to a u8
        let byte: &amp;u8 = unsafe { &amp;*(x as *const u8) };
    
        byte.method()
    }
    
    static Foo_for_u8_vtable: FooVtable = FooVtable {
        destructor: /* compiler magic */,
        size: 1,
        align: 1,
    
        // cast to a function pointer
        method: call_method_on_u8 as fn(*const ()) -&gt; String,
    };
    
    
    // String:
    
    fn call_method_on_String(x: *const ()) -&gt; String {
        // the compiler guarantees that this function is only called
        // with `x` pointing to a String
        let string: &amp;String = unsafe { &amp;*(x as *const String) };
    
        string.method()
    }
    
    static Foo_for_String_vtable: FooVtable = FooVtable {
        destructor: /* compiler magic */,
        // values for a 64-bit computer, halve them for 32-bit ones
        size: 24,
        align: 8,
    
        method: call_method_on_String as fn(*const ()) -&gt; String,
    };
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>FooVtable</span> {
    <span class='ident'>destructor</span>: <span class='kw'>fn</span>(<span class='op'>*</span><span class='kw-2'>mut</span> ()),
    <span class='ident'>size</span>: <span class='ident'>usize</span>,
    <span class='ident'>align</span>: <span class='ident'>usize</span>,
    <span class='ident'>method</span>: <span class='kw'>fn</span>(<span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span>,
}

<span class='comment'>// u8:</span>

<span class='kw'>fn</span> <span class='ident'>call_method_on_u8</span>(<span class='ident'>x</span>: <span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='comment'>// the compiler guarantees that this function is only called</span>
    <span class='comment'>// with `x` pointing to a u8</span>
    <span class='kw'>let</span> <span class='ident'>byte</span>: <span class='kw-2'>&amp;</span><span class='ident'>u8</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='kw-2'>&amp;</span><span class='op'>*</span>(<span class='ident'>x</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>) };

    <span class='ident'>byte</span>.<span class='ident'>method</span>()
}

<span class='kw'>static</span> <span class='ident'>Foo_for_u8_vtable</span>: <span class='ident'>FooVtable</span> <span class='op'>=</span> <span class='ident'>FooVtable</span> {
    <span class='ident'>destructor</span>: <span class='comment'>/* compiler magic */</span>,
    <span class='ident'>size</span>: <span class='number'>1</span>,
    <span class='ident'>align</span>: <span class='number'>1</span>,

    <span class='comment'>// cast to a function pointer</span>
    <span class='ident'>method</span>: <span class='ident'>call_method_on_u8</span> <span class='kw'>as</span> <span class='kw'>fn</span>(<span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span>,
};


<span class='comment'>// String:</span>

<span class='kw'>fn</span> <span class='ident'>call_method_on_String</span>(<span class='ident'>x</span>: <span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='comment'>// the compiler guarantees that this function is only called</span>
    <span class='comment'>// with `x` pointing to a String</span>
    <span class='kw'>let</span> <span class='ident'>string</span>: <span class='kw-2'>&amp;</span><span class='ident'>String</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='kw-2'>&amp;</span><span class='op'>*</span>(<span class='ident'>x</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>String</span>) };

    <span class='ident'>string</span>.<span class='ident'>method</span>()
}

<span class='kw'>static</span> <span class='ident'>Foo_for_String_vtable</span>: <span class='ident'>FooVtable</span> <span class='op'>=</span> <span class='ident'>FooVtable</span> {
    <span class='ident'>destructor</span>: <span class='comment'>/* compiler magic */</span>,
    <span class='comment'>// values for a 64-bit computer, halve them for 32-bit ones</span>
    <span class='ident'>size</span>: <span class='number'>24</span>,
    <span class='ident'>align</span>: <span class='number'>8</span>,

    <span class='ident'>method</span>: <span class='ident'>call_method_on_String</span> <span class='kw'>as</span> <span class='kw'>fn</span>(<span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span>,
};
</pre>

<p>Поле <code>destructor</code> в каждой виртуальной таблице указывает на функцию, которая
будет очищать любые ресурсы типа этой виртуальной таблицы, для <code>u8</code> она
тривиальна, но для <code>String</code> она будет освобождать память. Это необходимо для
владельцев трейт объектов, таких как <code>Box&lt;Foo&gt;</code>, для которых необходимо очищать
выделенную память как для <code>Box</code>, так и для внутреннего типа, когда они выходят
из области видимости. Поля <code>size</code> и <code>align</code> хранят размер затёртого типа, и его
требования к выравниванию; по существу, они не использовался в момент, так как
информация встроенного в деструктор, но будет использоваться в будущем, так как
объекты отличительным признакам постепенно становится более гибким.</p>

<p>Предположим, у нас есть несколько значений, которые реализуют <code>Foo</code>, тогда явный
вид создания и использования трейт объектов <code>Foo</code> может выглядеть примерно как
(игнорируются несоответствия типов: в любом случае, они всего лишь указатели):</p>
<span class='rusttest'>fn main() {
    let a: String = &quot;foo&quot;.to_string();
    let x: u8 = 1;
    
    // let b: &amp;Foo = &amp;a;
    let b = TraitObject {
        // store the data
        data: &amp;a,
        // store the methods
        vtable: &amp;Foo_for_String_vtable
    };
    
    // let y: &amp;Foo = x;
    let y = TraitObject {
        // store the data
        data: &amp;x,
        // store the methods
        vtable: &amp;Foo_for_u8_vtable
    };
    
    // b.method();
    (b.vtable.method)(b.data);
    
    // y.method();
    (y.vtable.method)(y.data);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='string'>&quot;foo&quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>u8</span> <span class='op'>=</span> <span class='number'>1</span>;

<span class='comment'>// let b: &amp;Foo = &amp;a;</span>
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>TraitObject</span> {
    <span class='comment'>// store the data</span>
    <span class='ident'>data</span>: <span class='kw-2'>&amp;</span><span class='ident'>a</span>,
    <span class='comment'>// store the methods</span>
    <span class='ident'>vtable</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo_for_String_vtable</span>
};

<span class='comment'>// let y: &amp;Foo = x;</span>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>TraitObject</span> {
    <span class='comment'>// store the data</span>
    <span class='ident'>data</span>: <span class='kw-2'>&amp;</span><span class='ident'>x</span>,
    <span class='comment'>// store the methods</span>
    <span class='ident'>vtable</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo_for_u8_vtable</span>
};

<span class='comment'>// b.method();</span>
(<span class='ident'>b</span>.<span class='ident'>vtable</span>.<span class='ident'>method</span>)(<span class='ident'>b</span>.<span class='ident'>data</span>);

<span class='comment'>// y.method();</span>
(<span class='ident'>y</span>.<span class='ident'>vtable</span>.<span class='ident'>method</span>)(<span class='ident'>y</span>.<span class='ident'>data</span>);
</pre>

<p>Если <code>b</code> или <code>y</code> были владельцами трейт объектов (<code>Box&lt;Foo&gt;</code>), то будут вызываны
деструкторы <code>(b.vtable.destructor)(b.data)</code> или <code>(y.vtable.destructor)(y.data)</code>
соответственно, как только они выйдут из своей области определения.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>