<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>C чего начать</title>

    <link rel="stylesheet" type="text/css" href="../rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../src/INTRODUCTION.html'><b>2.</b> Введение</a>
</li>
<li><a class='active' href='../src/getting-started.html'><b>3.</b> C чего начать</a>
</li>
<li><a  href='../src/learn-rust.html'><b>4.</b> Изучение Rust</a>
<ul class='section'>
<li><a  href='../src/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
<li><a  href='../src/dining-philosophers.html'><b>4.2.</b> Обедающие философы</a>
</li>
<li><a  href='../src/rust-inside-other-languages.html'><b>4.3.</b> Вызов кода на Rust из других языков</a>
</li>
</ul>
</li>
<li><a  href='../src/effective-rust.html'><b>5.</b> Эффективное использование Rust</a>
<ul class='section'>
<li><a  href='../src/the-stack-and-the-heap.html'><b>5.1.</b> Стек и куча</a>
</li>
<li><a  href='../src/testing.html'><b>5.2.</b> Тестирование</a>
</li>
<li><a  href='../src/conditional-compilation.html'><b>5.3.</b> Условная компиляция</a>
</li>
<li><a  href='../src/documentation.html'><b>5.4.</b> Документация</a>
</li>
<li><a  href='../src/iterators.html'><b>5.5.</b> Итераторы</a>
</li>
<li><a  href='../src/concurrency.html'><b>5.6.</b> Многозадачность</a>
</li>
<li><a  href='../src/error-handling.html'><b>5.7.</b> Обработка ошибок</a>
</li>
<li><a  href='../src/choosing-your-guarantees.html'><b>5.8.</b> Выбор гарантий</a>
</li>
<li><a  href='../src/ffi.html'><b>5.9.</b> Интерфейс внешних функций (FFI)</a>
</li>
<li><a  href='../src/borrow-and-asref.html'><b>5.10.</b> Типажи `Borrow` и `AsRef`</a>
</li>
<li><a  href='../src/release-channels.html'><b>5.11.</b> Каналы сборок</a>
</li>
</ul>
</li>
<li><a  href='../src/syntax-and-semantics.html'><b>6.</b> Синтаксис и семантика</a>
<ul class='section'>
<li><a  href='../src/variable-bindings.html'><b>6.1.</b> Связывание имён</a>
</li>
<li><a  href='../src/functions.html'><b>6.2.</b> Функции</a>
</li>
<li><a  href='../src/primitive-types.html'><b>6.3.</b> Простые типы</a>
</li>
<li><a  href='../src/comments.html'><b>6.4.</b> Комментарии</a>
</li>
<li><a  href='../src/if.html'><b>6.5.</b> Конструкция `if`</a>
</li>
<li><a  href='../src/loops.html'><b>6.6.</b> Циклы</a>
</li>
<li><a  href='../src/ownership.html'><b>6.7.</b> Владение</a>
</li>
<li><a  href='../src/references-and-borrowing.html'><b>6.8.</b> Ссылки и заимствование</a>
</li>
<li><a  href='../src/lifetimes.html'><b>6.9.</b> Время жизни</a>
</li>
<li><a  href='../src/mutability.html'><b>6.10.</b> Изменяемость (mutability)</a>
</li>
<li><a  href='../src/structs.html'><b>6.11.</b> Структуры</a>
</li>
<li><a  href='../src/enums.html'><b>6.12.</b> Перечисления</a>
</li>
<li><a  href='../src/match.html'><b>6.13.</b> Конструкция `match`</a>
</li>
<li><a  href='../src/patterns.html'><b>6.14.</b> Шаблоны сопоставления `match`</a>
</li>
<li><a  href='../src/method-syntax.html'><b>6.15.</b> Синтаксис методов</a>
</li>
<li><a  href='../src/vectors.html'><b>6.16.</b> Вектора</a>
</li>
<li><a  href='../src/strings.html'><b>6.17.</b> Строки</a>
</li>
<li><a  href='../src/generics.html'><b>6.18.</b> Обобщённое программирование</a>
</li>
<li><a  href='../src/traits.html'><b>6.19.</b> Типажи</a>
</li>
<li><a  href='../src/drop.html'><b>6.20.</b> Типаж `Drop` (сброс)</a>
</li>
<li><a  href='../src/if-let.html'><b>6.21.</b> Конструкция `if let`</a>
</li>
<li><a  href='../src/trait-objects.html'><b>6.22.</b> Типажи-объекты</a>
</li>
<li><a  href='../src/closures.html'><b>6.23.</b> Замыкания</a>
</li>
<li><a  href='../src/ufcs.html'><b>6.24.</b> Универсальный синтаксис вызова функций (UFCS)</a>
</li>
<li><a  href='../src/crates-and-modules.html'><b>6.25.</b> Контейнеры (crates) и модули (modules)</a>
</li>
<li><a  href='../src/const-and-static.html'><b>6.26.</b> `const` и `static`</a>
</li>
<li><a  href='../src/attributes.html'><b>6.27.</b> Атрибуты</a>
</li>
<li><a  href='../src/type-aliases.html'><b>6.28.</b> Псевдонимы типов</a>
</li>
<li><a  href='../src/casting-between-types.html'><b>6.29.</b> Приведение типов</a>
</li>
<li><a  href='../src/associated-types.html'><b>6.30.</b> Ассоциированные типы</a>
</li>
<li><a  href='../src/unsized-types.html'><b>6.31.</b> Безразмерные типы</a>
</li>
<li><a  href='../src/operators-and-overloading.html'><b>6.32.</b> Перегрузка операций</a>
</li>
<li><a  href='../src/deref-coercions.html'><b>6.33.</b> Преобразования при разыменовании (deref coercions)</a>
</li>
<li><a  href='../src/macros.html'><b>6.34.</b> Макросы</a>
</li>
<li><a  href='../src/raw-pointers.html'><b>6.35.</b> Сырые указатели</a>
</li>
<li><a  href='../src/unsafe.html'><b>6.36.</b> Небезопасный код</a>
</li>
</ul>
</li>
<li><a  href='../src/nightly-rust.html'><b>7.</b> Нестабильные возможности Rust</a>
<ul class='section'>
<li><a  href='../src/compiler-plugins.html'><b>7.1.</b> Плагины к компилятору</a>
</li>
<li><a  href='../src/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a  href='../src/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a  href='../src/intrinsics.html'><b>7.4.</b> Внутренние средства (intrinsics)</a>
</li>
<li><a  href='../src/lang-items.html'><b>7.5.</b> Элементы языка (lang items)</a>
</li>
<li><a  href='../src/advanced-linking.html'><b>7.6.</b> Продвинутое руководство по компоновке (advanced linking)</a>
</li>
<li><a  href='../src/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a  href='../src/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a  href='../src/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a  href='../src/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
<li><a  href='../src/custom-allocators.html'><b>7.11.</b> Пользовательские менеджеры памяти</a>
</li>
</ul>
</li>
<li><a  href='../src/glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a  href='../src/bibliography.html'><b>9.</b> Библиография</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">C чего начать</h1>
    <p>Первый раздел книги рассказывает о том, как начать работать с Rust и его
инструментами. Сначала мы установим Rust, затем напишем классическую программу
«Привет, мир!», и, наконец, поговорим о Cargo, который представляет из себя
систему сборки и менеджер пакетов в Rust.</p>

<h1 id='Установка-rust' class='section-header'><a href='#Установка-rust'>Установка Rust</a></h1>
<p>Первым шагом к использованию Rust является его установка. В этой главе нам
понадобится интернет соединение для выполнения команд, с помощью которых мы
загрузим Rust из интернета.</p>

<p>Мы воспользуемся несколькими командами в терминале, и они все будут начинаться
с <code>$</code>. Вам не нужно вводить <code>$</code>, они используются только для того чтобы
обозначить начало каждой команды. В интернете можно увидеть множество руководств
и примеров, которые следуют этому правилу: <code>$</code> обозначает команды, которые
выполняются с правами обычного пользователя и <code>#</code> для команд, которые
выполняются с правами администратора.</p>

<h2 id='Поддерживаемые-платформы' class='section-header'><a href='#Поддерживаемые-платформы'>Поддерживаемые платформы</a></h2>
<p>Перечень платформ, на которых работает и для которых компилирует компилятор
Rust довольно большой, однако, не все платформы поддерживаются одинаково.
Уровни поддержки Rust разбиты на три уровня, у каждого из которых свой набор
гарантий.</p>

<p>Платформы идентифицируются по их &quot;целевой тройке&quot;, которая является строкой,
сообщающей компилятору, какие выходные данные должны быть произведены. Столбцы
ниже указывают, работает ли соответствующий компонент на указанной платформе.</p>

<h3 id='Первый-уровень' class='section-header'><a href='#Первый-уровень'>Первый уровень</a></h3>
<p>Первый уровень платформ может восприниматься как &quot;гарантировано собирается и
работает&quot;. В частности, каждый из них удовлетворяет следующим требованиям:</p>

<ul>
<li>Автоматические тесты обеспечивают тестирование этих платформ.</li>
<li>Изменения, принятые в ветку master репозитория <code>rust-lang/rust</code>, прошли
тестирование.</li>
<li>Для этих платформ предоставляются официальные пакеты.</li>
<li>Доступна документация о том как собрать и использовать платформу.</li>
</ul>

<table>
<thead>
<tr>
<th>Target</th>
<th>std</th>
<th>rustc</th>
<th>cargo</th>
<th>notes</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>x86_64-pc-windows-msvc</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>64-bit MSVC (Windows 7+)</td>
</tr>
<tr>
<td><code>i686-pc-windows-gnu</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>32-bit MinGW (Windows 7+)</td>
</tr>
<tr>
<td><code>x86_64-pc-windows-gnu</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>64-bit MinGW (Windows 7+)</td>
</tr>
<tr>
<td><code>i686-apple-darwin</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>32-bit OSX (10.7+, Lion+)</td>
</tr>
<tr>
<td><code>x86_64-apple-darwin</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>64-bit OSX (10.7+, Lion+)</td>
</tr>
<tr>
<td><code>i686-unknown-linux-gnu</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>32-bit Linux (2.6.18+)</td>
</tr>
<tr>
<td><code>x86_64-unknown-linux-gnu</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>64-bit Linux (2.6.18+)</td>
</tr>
</tbody>
</table>

<h3 id='Второй-уровень' class='section-header'><a href='#Второй-уровень'>Второй уровень</a></h3>
<p>Второй уровень платформ может восприниматься как &quot;гарантировано собирается&quot;.
Автоматические тесты не поддерживаются и в связи с этим работоспособность сборки
не гарантируется. Но эти платформы обычно работают довольно хорошо, и
предложения по улучшению всегда приветствуются! В частности эти платформы
удовлетворяют следующим требованиям:</p>

<ul>
<li>Настроена автоматическая сборка, но тестирования не происходит.</li>
<li>Изменения, принятые в ветку master репозитория <code>rust-lang/rust</code>, собираются
для этих платформ. Имейте ввиду, что для некоторых платформ собирается только
стандартная библиотека, но для остальных настроена полная раскрутка
компилятора (bootstraping).</li>
<li>Для этих платформ предоставляются официальные пакеты.</li>
</ul>

<table>
<thead>
<tr>
<th>Target</th>
<th>std</th>
<th>rustc</th>
<th>cargo</th>
<th>notes</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>i686-pc-windows-msvc</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>32-bit MSVC (Windows 7+)</td>
</tr>
<tr>
<td><code>x86_64-unknown-linux-musl</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>64-bit Linux with MUSL</td>
</tr>
<tr>
<td><code>arm-linux-androideabi</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>ARM Android</td>
</tr>
<tr>
<td><code>arm-unknown-linux-gnueabi</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>ARM Linux (2.6.18+)</td>
</tr>
<tr>
<td><code>arm-unknown-linux-gnueabihf</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>ARM Linux (2.6.18+)</td>
</tr>
<tr>
<td><code>aarch64-unknown-linux-gnu</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>ARM64 Linux (2.6.18+)</td>
</tr>
<tr>
<td><code>mips-unknown-linux-gnu</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>MIPS Linux (2.6.18+)</td>
</tr>
<tr>
<td><code>mipsel-unknown-linux-gnu</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>MIPS (LE) Linux (2.6.18+)</td>
</tr>
</tbody>
</table>

<h3 id='Третий-уровень' class='section-header'><a href='#Третий-уровень'>Третий уровень</a></h3>
<p>Третий уровень платформ — это те, которые Rust поддерживает, но принятые
изменения автоматически не собираются и не тестируются. Для этих платформ
работоспособность сборки определятся степенью содействия сообщества. К тому же
официальные пакеты и установщики не предоставляются, но они могут быть
предоставлены сообществом.</p>

<table>
<thead>
<tr>
<th>Target</th>
<th>std</th>
<th>rustc</th>
<th>cargo</th>
<th>notes</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>i686-linux-android</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>32-bit x86 Android</td>
</tr>
<tr>
<td><code>aarch64-linux-android</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>ARM64 Android</td>
</tr>
<tr>
<td><code>powerpc-unknown-linux-gnu</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>PowerPC Linux (2.6.18+)</td>
</tr>
<tr>
<td><code>i386-apple-ios</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>32-bit x86 iOS</td>
</tr>
<tr>
<td><code>x86_64-apple-ios</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>64-bit x86 iOS</td>
</tr>
<tr>
<td><code>armv7-apple-ios</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>ARM iOS</td>
</tr>
<tr>
<td><code>armv7s-apple-ios</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>ARM iOS</td>
</tr>
<tr>
<td><code>aarch64-apple-ios</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>ARM64 iOS</td>
</tr>
<tr>
<td><code>i686-unknown-freebsd</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>32-bit FreeBSD</td>
</tr>
<tr>
<td><code>x86_64-unknown-freebsd</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>64-bit FreeBSD</td>
</tr>
<tr>
<td><code>x86_64-unknown-openbsd</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>64-bit OpenBSD</td>
</tr>
<tr>
<td><code>x86_64-unknown-netbsd</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>64-bit NetBSD</td>
</tr>
<tr>
<td><code>x86_64-unknown-bitrig</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>64-bit Bitrig</td>
</tr>
<tr>
<td><code>x86_64-unknown-dragonfly</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>64-bit DragonFlyBSD</td>
</tr>
<tr>
<td><code>x86_64-rumprun-netbsd</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>64-bit NetBSD Rump Kernel</td>
</tr>
<tr>
<td><code>i686-pc-windows-msvc</code> (XP)</td>
<td>✓</td>
<td></td>
<td></td>
<td>Windows XP support</td>
</tr>
<tr>
<td><code>x86_64-pc-windows-msvc</code> (XP)</td>
<td>✓</td>
<td></td>
<td></td>
<td>Windows XP support</td>
</tr>
</tbody>
</table>

<p>Имейте ввиду, что эта таблица со временем может быть дополнена, это не
исчерпывающий набор третьего уровня!</p>

<h2 id='Установка-на-linux-или-mac' class='section-header'><a href='#Установка-на-linux-или-mac'>Установка на Linux или Mac</a></h2>
<p>Если вы используете Linux или Mac, то всё что вам нужно сделать — это ввести
следующую команду в консоль:</p>

<pre><code class="language-bash">$ curl -sSf https://static.rust-lang.org/rustup.sh | sh
</code></pre>

<p>Эта команда загрузит скрипт и начнет установку. Если все пройдет успешно, то вы
увидите следующий текст:</p>

<pre><code class="language-text">Welcome to Rust.

This script will download the Rust compiler and its package manager, Cargo, and
install them to /usr/local. You may install elsewhere by running this script
with the --prefix=&lt;path&gt; option.

The installer will run under ‘sudo’ and may ask you for your password. If you do
not want the script to run ‘sudo’ then pass it the --disable-sudo flag.

You may uninstall later by running /usr/local/lib/rustlib/uninstall.sh,
or by running this script again with the --uninstall flag.

Continue? (y/N)
</code></pre>

<p>Нажмите <code>y</code> для подтверждения и следуйте дальнейшим подсказкам.</p>

<h2 id='Установка-на-windows' class='section-header'><a href='#Установка-на-windows'>Установка на Windows</a></h2>
<p>Если вы используете Windows, то скачайте подходящий <a href="https://www.rust-lang.org/install.html">установщик</a>.</p>

<h2 id='Удаление' class='section-header'><a href='#Удаление'>Удаление</a></h2>
<p>Удалить Rust так же просто, как и установить его. На Linux или Mac нужно просто
запустить скрипт удаления:</p>

<pre><code class="language-bash">$ sudo /usr/local/lib/rustlib/uninstall.sh
</code></pre>

<p>Если вы использовали установщик Windows, то просто повторно запустите <code>.msi</code>,
который предложит вам возможность удаления.</p>

<h2 id='Решение-проблем' class='section-header'><a href='#Решение-проблем'>Решение проблем</a></h2>
<p>Если у вас установлен Rust, то можно открыть терминал и ввести:</p>

<pre><code class="language-bash">$ rustc --version
</code></pre>

<p>Вы должны увидеть версию, хеш коммита и дату коммита.</p>

<p>Если это так, то теперь у вас есть установленный Rust! Поздравляем!</p>

<p>Если нет и вы пользователь Windows, то убедитесь в том, что Rust прописан в
вашей системной переменной %PATH%. Если это не так, то запустите установочник
снова, выберете &quot;Change&quot; на старнице &quot;Change, repair, or remove installation&quot; и
убедитесь, что &quot;Add to PATH&quot; указывает на локальный жесткий диск.</p>

<p>Существуют несколько мест, где вы можете получить помощь. Самый простой
вариант — <a href="irc://irc.mozilla.org/#rust">Канал #rust на irc.mozilla.org</a>, к которому вы можете
подключиться через <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Нажмите на эту ссылку, и вы будете общаться
в чате с другими Rustaceans (это дурашливое прозвище, которым мы себя называем),
и мы поможем вам. Другие полезные ресурсы, посвящённые Rust: <a href="https://users.rust-lang.org/">форум
пользователей</a> и <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.
Русскоязычные ресурсы: <a href="http://rustycrate.ru">сайт сообщества</a>, <a href="http://forum.rustycrate.ru">форум</a>,
<a href="http://ru.stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>

<p>Установщик также устанавливает документацию, которая доступна без подключения к
сети. На UNIX системах она располагается в директории
<code>/usr/local/share/doc/rust</code>. В Windows используется директория <code>share/doc</code>,
относительно того куда вы установили Rust.</p>

<h1 id='Привет-мир' class='section-header'><a href='#Привет-мир'>Привет, мир!</a></h1>
<p>Теперь, когда вы установили Rust, давайте напишем первую программу на Rust.
Традиционно при изучении нового языка программирования, первая написанная
программа просто выводит на экран «Привет, мир!», и мы следуем этой традиции.</p>

<p>Хорошо начинать с такой простой программы, поскольку можно убедиться, что ваш
компилятор не только установлен, но и работает правильно. Вывод информации на
экран будет замечательным способом проверить это.</p>

<blockquote>
<p>На самом деле это приводит к ещё одной проблеме, о которой мы должны
предупредить: данное руководство предполагает, что у вас есть базовые навыки
работы с командной строкой. Rust не выдвигает специфических требований к вашей
среде разработки или тому, как вы храните свой код. Если вы предпочитаете
использовать IDE, посмотрите на проект <a href="https://github.com/oakes/SolidOak">SolidOak</a>, или на плагины к
вашей любимой IDE. Есть множество расширений, разрабатываемых сообществом, а
также <a href="https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md">плагинов для разных редакторов</a>, поддерживаемых командой Rust.
Настройка вашего редактора или IDE выходит за пределы данного руководства.
Посмотрите руководство по использованию выбранного вами плагина.</p>
</blockquote>

<h2 id='Создание-проекта' class='section-header'><a href='#Создание-проекта'>Создание проекта</a></h2>
<p>Первое, с чего мы должны начать – создание файла для нашего кода. Для Rust не
имеет значения, где находится ваш код, но в рамках этого руководства мы
рекомендуем создать директорию <em>projects</em> в вашей домашней директории и хранить
там все ваши проекты. Откройте терминал и введите следующие команды чтобы
создать директорию для этого проекта:</p>

<pre><code class="language-bash">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>

<blockquote>
<p>Если вы используете Windows и не используете PowerShell, ~ может не работать.
Обратитесь к документации вашей оболочки для уточнения деталей.</p>
</blockquote>

<h2 id='Написание-и-запуск-программы-на-rust' class='section-header'><a href='#Написание-и-запуск-программы-на-rust'>Написание и запуск программы на Rust</a></h2>
<p>Теперь создадим новый файл для кода программы. Назовём наш файл <em>main.rs</em>.
Файлы с исходным кодом на Rust всегда имеют расширение <em>.rs</em>. Если вы
хотите использовать в имени вашего файла больше одного слова, разделяйте их
подчёркиванием; например <em>hello_world.rs</em>, а не <em>helloworld.rs</em>.</p>

<p>Теперь откройте только что созданный файл <em>main.rs</em> и добавьте в него следующий
код:</p>
<span class='rusttest'>fn main() {
    println!(&quot;Привет, мир!&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Привет, мир!&quot;</span>);
}</pre>

<p>Сохраните файл и вернитесь к вашему окну терминала. На Linux или OSX введите
следующие команды:</p>

<pre><code class="language-bash">$ rustc main.rs
$ ./main
Привет, мир!
</code></pre>

<p>На Windows просто замените <code>main</code> на <code>main.exe</code>. В независимости от вашей ОС
вы должны увидеть строку <code>Привет, мир!</code> в терминале. Поздравляем! Вы написали
первую программу на Rust. Теперь вы Rust-разработчик! Добро пожаловать!</p>

<h2 id='Анатомия-программ-на-rust' class='section-header'><a href='#Анатомия-программ-на-rust'>Анатомия программ на Rust</a></h2>
<p>Теперь давайте детально разберемся, что происходит в программе &quot;Привет, мир!&quot;.
Вот первый кусочек головоломки:</p>
<span class='rusttest'>fn main() {

}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {

}</pre>

<p>Эти строки объявляют «функцию» в Rust. Функция <code>main</code> особенна: это начало
каждой программы на Rust. Первая строка говорит: «Мы объявляем функцию,
именуемую <code>main</code>, которая не получает параметров и ничего не возвращает». Если
бы мы хотели передать в функцию параметры, то указали бы их в скобках (<code>(</code> и
<code>)</code>). Поскольку нам не надо ничего возвращать из этой функции, мы можем опустить
указание типа возвращаемого значения. Мы вернёмся к этому позже.</p>

<p>Вы должны были заметить, что функция обёрнута в фигурные скобки (<code>{</code> и <code>}</code>).
Rust требует оборачивать ими тело любой функции. Также хорошим стилем считается
ставить открывающую фигурную скобку на той же строке, что и объявление функции,
отделённую от него одним пробелом.</p>

<p>Теперь эта строка:</p>
<span class='rusttest'>fn main() {
        println!(&quot;Привет, мир!&quot;);
    
}</span><pre class='rust rust-example-rendered'>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Привет, мир!&quot;</span>);</pre>

<p>Эта строка делает всю работу в нашей маленькой программе: выводит текст на
экран. Тут есть несколько нюансов, которые имеют существенное значение.
Во-первых, отступ в четыре пробела, а не табуляция.</p>

<p>Теперь разберёмся с <code>println!()</code>. Это вызов одного из <a href="macros.html">макросов</a>,
которыми представлено метапрограммирование в Rust. Если бы вместо макроса была
функция, это выглядело бы следующим образом: <code>println()</code> (без <code>!</code>). Позже мы
обсудим макросы Rust подробнее, а на данный момент все что вам нужно знать: если
вы видите <code>!</code>, то вызывается макрос вместо обычной функции.</p>

<p>Идём дальше. <code>&quot;Привет, мир!&quot;</code> — это «строка». Строки — это удивительно сложная
тема для системного языка программирования. Это <a href="the-stack-and-the-heap.html">статически расположенная в
памяти</a> строка. Мы передаём строку в качестве аргумента в
<code>println!</code>, который выводит строки на экран. Достаточно просто!</p>

<p>Cтрока заканчивается точкой с запятой (<code>;</code>). Rust — <a href="glossary.html#expression-oriented-language">язык с ориентацией на
выражения</a>, а это означает, что в нём большая
часть вещей является выражением. <code>;</code> используется для указания конца выражения и
начала следующего. Большинство строк кода на Rust заканчивается символом <code>;</code>.</p>

<h2 id='Компиляция-и-запуск-это-отдельные-шаги' class='section-header'><a href='#Компиляция-и-запуск-это-отдельные-шаги'>Компиляция и запуск это отдельные шаги</a></h2>
<p>В разделе &quot;Написание и запуск программы на Rust&quot; мы рассмотрели как запустить
только что созданную программу. Теперь мы разберем каждый шаг по отдельности.</p>

<p>Перед запуском программы ее нужно скомпилировать. Вы можете воспользоваться
компилятором Rust с помощью команды <code>rustc</code> и передать ваш файл, как показано
здесь:</p>

<pre><code class="language-bash">$ rustc main.rs
</code></pre>

<p>Если раньше вы программировали на С или С++, то заметите, что это напоминает
<code>gcc</code> или <code>clang</code>. После успешной компиляции Rust создаст двоичный исполняемый
файл. На Linux или OSX вы можете убедиться в этом с помощью команды <code>ls</code>:</p>

<pre><code class="language-bash">$ ls
main  main.rs
</code></pre>

<p>Или в Windows:</p>

<pre><code class="language-bash">$ dir
main.exe  main.rs
</code></pre>

<p>У нас есть два файла: файл с нашим исходным кодом, с расширением <code>.rs</code>, и
исполняемый файл (<code>main.exe</code> в Windows, <code>main</code> в остальных случаях). Все что
осталось сделать — это запустить <code>main</code> или <code>main.exe</code>:</p>

<pre><code class="language-bash">$ ./main  # или main.exe на Windows
</code></pre>

<p>Мы вывели наш текст <code>&quot;Привет, мир!&quot;</code> в окне терминала.</p>

<p>Если раньше вы использовали динамические языки программирования вроде Ruby,
Python или JavaScript, то возможно разделение компиляции и запуска покажется вам
странным. Rust — это язык, на котором программы <em>компилируются перед
исполнением</em>. Это означает, что вы можете собрать программу, дать её кому-то
ещё, и ему не нужно устанавливать Rust для запуска этой программы. Если вы
передадите кому-нибудь <code>.rb</code>, <code>.py</code> или <code>.js</code> файл, им понадобится интерпретатор
Ruby, Python или JavaScript чтобы скомпилировать и запустить вашу программу (это
делается одной командой). В мире языков программирования много компромиссов, и
Rust сделал свой выбор.</p>

<p>Использовать <code>rustc</code> удобно лишь для небольших программ, но по мере роста
проекта, потребуется инструмент, который поможет управлять настройками проекта,
а также позволяет проще делиться кодом с другими людьми и проектами. Далее мы
познакомимся с новым инструментом <code>Cargo</code>, который используется для написания
настоящих программ на Rust.</p>

<h1 id='Привет-cargo' class='section-header'><a href='#Привет-cargo'>Привет, Cargo!</a></h1>
<p>Cargo — это система сборки и пакетный менеджер для Rust, и Rustaceans используют
его для управления своими проектами на Rust. Cargo заботится о трех вещах:
сборка кода, загрузка библиотек, от которых зависит ваш код, и сборка этих
библиотек. Библиотеки, которые нужны вашему коду, мы называем &quot;зависимостями&quot;
(&quot;dependencies&quot;), поскольку ваш код зависит от них.</p>

<p>Поначалу вашей программе не понадобится никаких зависимостей, поэтому будем
использовать только первую часть его возможностей. Со временем нам понадобится
добавить несколько зависимостей, и нам не составит труда сделать это, используя
Cargo.</p>

<p>Подавляющее количество проектов на Rust используют Cargo, по-этому в рамках этой
книги мы будем исходить из того, что вы тоже делаете это. Если вы использовали
официальный установщик, то Cargo установился вместе с Rust. Если же вы
установили Rust каким-либо другим образом, то вы можете проверить, есть ли у вас
Cargo введя следующую команду в терминал:</p>

<pre><code class="language-bash">$ cargo --version
</code></pre>

<p>Если вы увидели номер версии, то все в порядке. Если же вы увидели сообщение об
ошибке на подобии &quot;<code>команда не найдена</code>&quot;, то вам нужно ознакомится с
документацией для системы, в которой вы установили Rust.</p>

<h2 id='Переход-на-cargo' class='section-header'><a href='#Переход-на-cargo'>Переход на Cargo</a></h2>
<p>Давайте переведем наш проект &quot;Привет, мир&quot; на использование Cargo. Для перехода
на Cargo нужно сделать три вещи:</p>

<ol>
<li>Расположить файл с исходным кодом в правильной директории.</li>
<li>Избавиться от старого исполняемого файла (<code>main.exe</code> или <code>main</code>) и сделать
новый.</li>
<li>Создать конфигурационный файл для Cargo.</li>
</ol>

<p>Давайте сделаем это!</p>

<h3 id='Создание-нового-исполняемого-файла-и-директории-с-исходным-кодом' class='section-header'><a href='#Создание-нового-исполняемого-файла-и-директории-с-исходным-кодом'>Создание нового исполняемого файла и директории с исходным кодом</a></h3>
<p>Для начала вернитесь к вашему терминалу, перейдите в вашу директорию
<em>hello_world</em> и введите следующие команды:</p>

<pre><code class="language-bash">$ mkdir src
$ mv main.rs src/main.rs
$ rm main  # или &#39;del main.exe&#39; для Windows
</code></pre>

<p>Cargo ожидает что ваши файлы с исходным кодом находятся в директории <em>src</em>.
Такой подход оставляет верхний уровнь вашего проекта для вещей, вроде README,
файлов с текстом лицензии и других не относящихся к вашему коду. Cargo помогает
нам сохранять наши проекты красивыми и аккуратными. Всему есть свое место и все
находится на своих местах.</p>

<p>Теперь скопируйте <em>main.rs</em> в директорию <em>src</em> и удалите скомпилированный файл,
который вы создали с помощью <code>rustc</code>.</p>

<p>Отметим, что поскольку мы создаём исполняемый файл, то мы используем <code>main.rs</code>.
Если бы мы хотели создать библиотеку, то мы использовали бы lib.rs. Cargo
использует это соглашение для успешной компиляции вашего проекта, но вы можете
это изменить, если захотите.</p>

<h3 id='Создание-конфигурационного-файла' class='section-header'><a href='#Создание-конфигурационного-файла'>Создание конфигурационного файла</a></h3>
<p>Теперь создайте новый файл внутри директории <em>hello_world</em> и назовите его
<code>Cargo.toml</code>.</p>

<p>Убедитесь в том, что имя правильное: вам нужна заглавная <code>C</code>! В противном случае
Cargo не найдет конфигурационный файл.</p>

<p>Это файл в формате <a href="Tom&#x27;s%20Obvious,%20Minimal%20Language">TOML</a>. TOML это аналог
INI, но с некоторыми дополнениями, и он используется в конфигурационных файлах
для Cargo.</p>

<p>Вставьте следующую информацию внутрь этого файла:</p>

<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [ &quot;Your name &lt;you@example.com&gt;&quot; ]
</code></pre>

<p>Первая строка, <code>[package]</code>, говорит о том, что следующие параметры отвечают за
настройку пакета. Когда нам понадобится добавить больше информации в этот файл,
мы создадим другие разделы, но сейчас нам достаточно настроек пакета.</p>

<p>Другие три строчки устанавливают три значения конфигурации, которые необходимы
Cargo для компиляции вашей программы: имя, версия и автор.</p>

<p>После того как вы добавили эту информацию в <em>Cargo.toml</em>, сохраните изменения.
На этом создание конфигурационного файла завершено.</p>

<h2 id='Сборка-и-запуск-cargo-проекта' class='section-header'><a href='#Сборка-и-запуск-cargo-проекта'>Сборка и запуск Cargo проекта</a></h2>
<p>Теперь, после создания файла <code>Carto.toml</code> в корневой директории, мы готовы
приступить к сборке и запуску нашего проекта. Чтобы сделать это, введите
следующие команды:</p>

<pre><code class="language-bash">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
$ ./target/debug/hello_world
Привет, мир!
</code></pre>

<p>Та-да! Мы собрали наш проект вызвав <code>cargo build</code> и запустили его с помощью
<code>./target/debug/hello_world</code>. Мы можем сделать это в один шаг используя <code>cargo run</code>:</p>

<pre><code class="language-bash">$ cargo run
     Running `target/debug/hello_world`
Привет, мир!
</code></pre>

<p>Заметьте, что сейчас мы не пересобрали наш проект. Cargo понял, что мы не
изменили файл с исходным кодом и сразу запустил исполняемый файл. Если бы мы
изменили файл, мы бы увидели оба шага:</p>

<pre><code class="language-bash">$ cargo run
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
     Running `target/debug/hello_world`
Привет, мир!
</code></pre>

<p>На первый взгляд это кажется сложнее, по сравнению с более простым
использованием <code>rustc</code>, но давайте подумаем о будущем: если в нашем проекте
будет больше одного файла, мы должны будем вызывать rustc для каждого из них и
передавать кучу параметров, чтобы собрать их вместе. С Cargo, когда наш проект
вырастет, нам понадобится вызвать только команду <code>cargo build</code> и она всё сделает
за нас.</p>

<h2 id='Сборка-релизной-версии' class='section-header'><a href='#Сборка-релизной-версии'>Сборка релизной версии</a></h2>
<p>Когда вы закончите работать над проектом, и он окончательно будет готов к
релизу, используйте команду <code>cargo build --release</code> для компиляции вашего
проекта с оптимизацией. Эти оптимизации делают ваш код на Rust быстрее, но
требуют больше времени на компиляцию. Именно из-за этого существует два разных
способа: один для разработки, другой для сборки финальной версии, которую вы
отдалите пользователям.</p>

<p>Также вы должны были заметить, что Cargo создал новый файл: <code>Cargo.lock</code>.</p>

<pre><code class="language-toml">[root]
name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
</code></pre>

<p>Этот файл используется Cargo для отслеживания зависимостей в вашем приложении.
Прямо сейчас у нас нет ни одной, поэтому этот файл немного пустоват. Вам не
нужно редактировать этот файл самостоятельно, Cargo сам с ним разберётся.</p>

<p>Вот и все! Мы успешно собрали <code>hello_world</code> с помощью Cargo.</p>

<p>Несмотря на то, что наша программа проста, мы использовали большую часть
реальных инструментов, которые вы будете использовать в своём дальнейшем пути
Rust-программиста. Более того, вы можете расчитывать, что практически все
проекты на Rust можно будет собрать с помощью вариации этих команд:</p>

<pre><code class="language-bash">$ git clone someurl.com/foo
$ cd foo
$ cargo build
</code></pre>

<h2 id='Простой-способ-создать-новый-cargo-проект' class='section-header'><a href='#Простой-способ-создать-новый-cargo-проект'>Простой способ создать новый Cargo проект</a></h2>
<p>Вам не нужно повторять вышеприведённые шаги каждый раз, когда вы хотите создать
новый проект! Cargo может создать директорию проекта, в которой вы сразу сможете
приступить к разработке.</p>

<p>Чтобы создать новый проект с помощью Cargo, нужно ввести команду <code>cargo new</code>:</p>

<pre><code class="language-bash">$ cargo new hello_world --bin
</code></pre>

<p>Мы указываем аргумент <code>--bin</code>, так как хотим создать исполняемую программу. Если
мы не укажем этот аргумент, то Cargo создаст проект для библиотеки. Исполняемые
файлы частно называют <em>бинарниками</em> (поскольку обычно они находятся в
<code>/usr/bin</code>, если вы используете Unix систему).</p>

<p>Cargo сгенерировал два файла и одну директорию: <code>Cargo.toml</code> и директорию <em>src</em>
с файлом <em>main.rs</em>. Они должны выглядеть так же как те, что мы создали до этого.</p>

<p>Этого достаточно для того чтобы начать. Открыв <code>Cargo.toml</code>, вы должны увидеть
следующее:</p>

<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
</code></pre>

<p>Cargo наполнил этот файл значениями по умолчанию на основании переданных
аргументов и глобальной конфигурации <code>git</code>. Также он инициализировал
директорию <code>hello_world</code> как <code>git</code> репозитоий.</p>

<p>Вот что должно быть внутри <code>src/main.rs</code>:</p>
<span class='rusttest'>fn main() {
    println!(&quot;Hello, world!&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, world!&quot;</span>);
}</pre>

<p>Cargo создал «Hello World!» для нас и вы уже можете приступить к
программированию!</p>

<blockquote>
<p>У Cargo есть собственное <a href="http://doc.crates.io/guide.html">руководство</a>, в котором про него рассказано
более детально.</p>
</blockquote>

<h1 id='Заключение' class='section-header'><a href='#Заключение'>Заключение</a></h1>
<p>Это основы, которые вы будете часто использовать на протяжении всего вашего
взаимодействия с Rust. Теперь давайте отложим инструментарий и узнаем больше о
самом языке.</p>

<p>У вас есть два пути: погрузиться в изучение реального проекта, открыв раздел
«<a href="learn-rust.html">Изучение Rust</a>», или начать с самого низа и постепенно продвигаться
наверх, начав с раздела «<a href="syntax-and-semantics.html">Синтаксис и семантика</a>». Программисты, имеющие
опыт работы с системными языками, вероятно, предпочтут «Изучение Rust», в то
время как программисты, имеющие опыт работы с динамическими языками, скорее
всего захотят пойти по второму пути. Разные люди учатся по-разному! Выберите то,
что подходит именно вам.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>