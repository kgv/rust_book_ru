% Строки

Строки являются важным понятием для любого ведущего программиста. Система
обработки строк в Rust немного отличается от других языков, в связи с его
фокусировкой на системный уровень. Всякий раз, когда вы имеете дело со
структурой данных с переменным размером, все может стать слишком запутанным, и
строки как раз являются структурой данных с переменным размером. Кроме того,
работа со строками в Rust также отличается и от некоторых системных языков,
таких как C.

Давайте разбираться в деталях. *string* - это последовательность скалярных
значений юникод, закодированных в виде потока UTF-8 байт. Все строки должны быть
гарантированно валидными UTF-8 последовательностями. Кроме того, строки не
оканчиваются нулем и могут содержать нулевые байты.

В Rust есть два основных типа строк: `&str` и `String`. Сперва поговорим о
`&str`. Это произносится как 'строковый срез (слайс)'. Строковые литералы имеют
тип `&'static str`:

```rust
let string = "Hello there."; // string: &'static str
```

Эта строка выделяется статически, что означает, что она сохраняется в нашей
скомпилированной программе и существует в течение всего периода ее выполнения.
`string` привязка представляет собой ссылку на эту статически размещенную
строку. Строковые срезы имеют фиксированный размер и не могут быть изменены.

`String` же, напротив, выделяется в куче. Эта строка расширяема, а также она
гарантированно является UTF-8 последовательностью. `String` обычно создается
путем преобразования из строкового среза с использованием метода `to_string`.

```rust
let mut s = "Hello".to_string(); // mut s: String
println!("{}", s);

s.push_str(", world.");
println!("{}", s);
```

`String` преобразуются в `&str` с помощью `&`:

```rust
fn takes_slice(slice: &str) {
    println!("Got: {}", slice);
}

fn main() {
    let s = "Hello".to_string();
    takes_slice(&s);
}
```

Представление `String` как `&str` является дешевой операцией, но преобразование
`&str` в `String` предполагает выделение памяти. Нет причин делать это, если в
этом нет необходимости!

## Индексация

Поскольку строки являются валидными UTF-8 последовательностями, то они не
поддерживают индексацию:

```rust,ignore
let s = "hello";

println!("The first letter of s is {}", s[0]); // ERROR!!!
```

Как правило, доступ к вектору с помощью `[]` является очень быстрой операцией.
Но поскольку каждый символ в строке, закодированной UTF-8, может быть
представлен несколькими байтами, то при поиске вы должны перебрать n-ое
количество литер в строке. Это значительно более дорогая операция, а мы не хотим
вводить в заблуждение. Кроме того, "литера" - это не совсем то, что определено в
Unicode. Мы можем выбрать как рассматиравать строку: как отдельные байты или как
кодовые единицы:

```rust
let hachiko = "忠犬ハチ公";

for b in hachiko.as_bytes() {
    print!("{}, ", b);
}

println!("");

for c in hachiko.chars() {
    print!("{}, ", c);
}

println!("");
```

Этот код напечатает:

```text
229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172, 
忠, 犬, ハ, チ, 公, 
```

Как вы можете видеть, количество байт больше, чем количество символов (`char`).

Вы можете получить что-то наподобие индекса, как показано ниже:

```rust
# let hachiko = "忠犬ハチ公";
let dog = hachiko.chars().nth(1); // kinda like hachiko[1]
```

Это подчеркивает, что мы должны пройти через весь список `chars`.

## Конкатенация

Если у вас есть `String`, то вы можете присоединить к ней в конец `&str`:

```rust
let hello = "Hello ".to_string();
let world = "world!";

let hello_world = hello + world;
```

Но если у вас есть две `String`, то необходимо использовать `&`:

```rust
let hello = "Hello ".to_string();
let world = "world!".to_string();

let hello_world = hello + &world;
```

Это потому, что `&String` может быть автоматически приведен к `&str`. Эта фича
называется "[Приведение при разыменовании][dc]".

[dc]: deref-coercions.html
