<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Угадайка</title>

    <link rel="stylesheet" type="text/css" href="../rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='../src/README.html'><b>2.</b> Введение</a>
</li>
<li><a href='../src/getting-started.html'><b>3.</b> C чего начать</a>
<ul class='section'>
<li><a href='../src/installing-rust.html'><b>3.1.</b> Установка Rust</a>
</li>
<li><a href='../src/hello-world.html'><b>3.2.</b> Hello, world!</a>
</li>
<li><a href='../src/hello-cargo.html'><b>3.3.</b> Hello, Cargo!</a>
</li>
</ul>
</li>
<li><a href='../src/learn-rust.html'><b>4.</b> Изучение Rust</a>
<ul class='section'>
<li><a href='../src/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
<li><a href='../src/dining-philosophers.html'><b>4.2.</b> Обедающие философы</a>
</li>
<li><a href='../src/rust-inside-other-languages.html'><b>4.3.</b> Вызов кода на Rust из других языков</a>
</li>
</ul>
</li>
<li><a href='../src/effective-rust.html'><b>5.</b> Эффективное использование Rust</a>
<ul class='section'>
<li><a href='../src/the-stack-and-the-heap.html'><b>5.1.</b> Стек и Куча</a>
</li>
<li><a href='../src/testing.html'><b>5.2.</b> Тестирование</a>
</li>
<li><a href='../src/conditional-compilation.html'><b>5.3.</b> Условная компиляция</a>
</li>
<li><a href='../src/documentation.html'><b>5.4.</b> Документация</a>
</li>
<li><a href='../src/iterators.html'><b>5.5.</b> Итераторы</a>
</li>
<li><a href='../src/concurrency.html'><b>5.6.</b> Многозадачность</a>
</li>
<li><a href='../src/error-handling.html'><b>5.7.</b> Обработка ошибок</a>
</li>
<li><a href='../src/ffi.html'><b>5.8.</b> Интерфейс внешних функций (FFI)</a>
</li>
<li><a href='../src/release-channels.html'><b>5.9.</b> Каналы сборок</a>
</li>
</ul>
</li>
<li><a href='../src/syntax-and-semantics.html'><b>6.</b> Синтаксис и семантика</a>
<ul class='section'>
<li><a href='../src/variable-bindings.html'><b>6.1.</b> Связывание переменных</a>
</li>
<li><a href='../src/functions.html'><b>6.2.</b> Функции</a>
</li>
<li><a href='../src/primitive-types.html'><b>6.3.</b> Простые типы</a>
</li>
<li><a href='../src/comments.html'><b>6.4.</b> Комментарии</a>
</li>
<li><a href='../src/if.html'><b>6.5.</b> Конструкция `if`</a>
</li>
<li><a href='../src/for-loops.html'><b>6.6.</b> Циклы `for`</a>
</li>
<li><a href='../src/while-loops.html'><b>6.7.</b> Циклы `while`</a>
</li>
<li><a href='../src/ownership.html'><b>6.8.</b> Владение</a>
</li>
<li><a href='../src/references-and-borrowing.html'><b>6.9.</b> Ссылки и Заимствование</a>
</li>
<li><a href='../src/lifetimes.html'><b>6.10.</b> Время жизни</a>
</li>
<li><a href='../src/mutability.html'><b>6.11.</b> Изменяемость (Мутабельность)</a>
</li>
<li><a href='../src/enums.html'><b>6.12.</b> Перечисления</a>
</li>
<li><a href='../src/match.html'><b>6.13.</b> Конструкция `match`</a>
</li>
<li><a href='../src/structs.html'><b>6.14.</b> Структуры</a>
</li>
<li><a href='../src/patterns.html'><b>6.15.</b> Шаблоны `match`</a>
</li>
<li><a href='../src/method-syntax.html'><b>6.16.</b> Синтаксис методов</a>
</li>
<li><a href='../src/vectors.html'><b>6.17.</b> Вектора</a>
</li>
<li><a href='../src/strings.html'><b>6.18.</b> Строки</a>
</li>
<li><a href='../src/generics.html'><b>6.19.</b> Дженерики</a>
</li>
<li><a href='../src/traits.html'><b>6.20.</b> Типажи</a>
</li>
<li><a href='../src/drop.html'><b>6.21.</b> Типаж `Drop`</a>
</li>
<li><a href='../src/if-let.html'><b>6.22.</b> Конструкция `if let`</a>
</li>
<li><a href='../src/trait-objects.html'><b>6.23.</b> Типажи-объекты</a>
</li>
<li><a href='../src/closures.html'><b>6.24.</b> Замыкания</a>
</li>
<li><a href='../src/ufcs.html'><b>6.25.</b> Универсальный синтаксис вызова функций (UFCS)</a>
</li>
<li><a href='../src/crates-and-modules.html'><b>6.26.</b> Контейнеры и Модули</a>
</li>
<li><a href='../src/const-and-static.html'><b>6.27.</b> `const` и `static`</a>
</li>
<li><a href='../src/tuple-structs.html'><b>6.28.</b> Кортежные структуры</a>
</li>
<li><a href='../src/attributes.html'><b>6.29.</b> Атрибуты</a>
</li>
<li><a href='../src/type-aliases.html'><b>6.30.</b> Псевдонимы типов</a>
</li>
<li><a href='../src/casting-between-types.html'><b>6.31.</b> Преобразование типов</a>
</li>
<li><a href='../src/associated-types.html'><b>6.32.</b> Ассоциированные типы</a>
</li>
<li><a href='../src/unsized-types.html'><b>6.33.</b> Безразмерные типы</a>
</li>
<li><a href='../src/operators-and-overloading.html'><b>6.34.</b> Operators and Overloading</a>
</li>
<li><a href='../src/deref-coercions.html'><b>6.35.</b> Типаж `Deref`</a>
</li>
<li><a href='../src/macros.html'><b>6.36.</b> Макросы</a>
</li>
<li><a href='../src/raw-pointers.html'><b>6.37.</b> Сырые указатели</a>
</li>
<li><a href='../src/unsafe.html'><b>6.38.</b> `unsafe` код</a>
</li>
</ul>
</li>
<li><a href='../src/nightly-rust.html'><b>7.</b> Нестабильные возможности Rust</a>
<ul class='section'>
<li><a href='../src/compiler-plugins.html'><b>7.1.</b> Плагины компилятора</a>
</li>
<li><a href='../src/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a href='../src/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a href='../src/intrinsics.html'><b>7.4.</b> Внутренние средства</a>
</li>
<li><a href='../src/lang-items.html'><b>7.5.</b> Lang items</a>
</li>
<li><a href='../src/link-args.html'><b>7.6.</b> Аргументы линковки</a>
</li>
<li><a href='../src/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a href='../src/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a href='../src/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a href='../src/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
</ul>
</li>
<li><a href='../src/glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a href='../src/academic-research.html'><b>9.</b> Академические исследования</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Угадайка</h1>
    <p>В качестве нашего первого проекта, мы решим классическую для начинающих
программистов задачу: игра-угадайка. Немного о том, как игра должна работать:
наша программа генерирует случайное целое число из промежутка от 1 до 100. Затем
она просит ввести число, которое она &quot;загадала&quot;. Для каждого введённого нами
числа, она говорит, больше ли оно, чем &quot;загаданное&quot;, или меньше. Игра
заканчивается когда мы отгадываем число. Звучит не плохо, не так ли?</p>

<h1 id="Создание-нового-проекта" class='section-header'><a
                           href="#Создание-нового-проекта">Создание нового проекта</a></h1>
<p>Давайте создадим новый проект. Перейдите в вашу директорию с проектами. Помните,
как мы создавали структуру директорий и <code>Cargo.toml</code> для <code>hello_world</code>? Cargo
может сделать это за нас. Давайте воспользуемся этим:</p>

<pre><code class="language-bash">$ cd ~/projects
$ cargo new guessing_game --bin
$ cd guessing_game
</code></pre>

<p>Мы сказали Cargo, что хотим создать новый проект с именем <code>guessing_game</code>.При
помощи флага <code>--bin</code>, мы указали что хотим создать исполняемый файл, а не
библиотеку.</p>

<p>Давайте посмотрим сгенерированный <code>Cargo.toml</code>:</p>

<pre><code class="language-toml">[package]

name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
</code></pre>

<p>Cargo взял эту информацию из вашего рабочего окружения. Если информация не
корректна, исправьте её.</p>

<p>Наконец, Cargo создал программу <code>Hello, world!</code>. Посмотрите файл
<code>src/main.rs</code>:</p>
<span class='rusttest'>fn main() {
    println!(&quot;Hello, world!&quot;)
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, world!&quot;</span>)
}
</pre>

<p>Давайте попробуем скомпилировать созданный Cargo проект:</p>

<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>

<p>Замечательно! Снова откройте <code>src/main.rs</code>. Мы будем писать весь наш код в этом
файле.</p>

<p>Прежде, чем мы начнём работу, давайте рассмотрим ещё одну команду Cargo: <code>run</code>.
<code>cargo run</code> похожа на <code>cargo build</code>, но после завершения компиляции, она
запускает получившийся исполняемый файл:</p>

<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>

<p>Великолепно! Команда <code>run</code> помогает, когда надо быстро пересобирать проект. Наша
игра как раз и есть такой проект: нам надо быстро тестировать каждое изменение,
прежде чем мы приступим к следующей части программы.</p>

<h1 id="Обработка-предположения" class='section-header'><a
                           href="#Обработка-предположения">Обработка предположения</a></h1>
<p>Давайте начнём! Первая вещь, которую мы должны сделать для нашей игры - это
позволить игроку вводить предположения. Поместите следующий код в ваш
<code>src/main.rs</code>:</p>
<span class='rusttest'>use std::io;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    println!(&quot;Пожалуйста, введите предположение.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .ok()
        .expect(&quot;Не удалось прочитать строку&quot;);

    println!(&quot;Вы загадали: {}&quot;, guess);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Угадайте число!&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Пожалуйста, введите предположение.&quot;</span>);

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>guess</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>guess</span>)
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;Не удалось прочитать строку&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Вы загадали: {}&quot;</span>, <span class='ident'>guess</span>);
}
</pre>

<p>Здесь много чего! Давайте разберём этот участок по частям.</p>
<span class='rusttest'>fn main() {
    use std::io;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
</pre>

<p>Нам надо получить то, что ввёл пользователь, а затем вывести результат на экран.
Значит нам понадобится библиотека <code>io</code> из стандартной библиотеки. Изначально, во
<a href="http://doc.rust-lang.org/std/prelude/index.html">вступлении</a> (prelude), Rust импортирует в нашу программу лишь самые
необходимые вещи. Если чего-то нет по вступлении, мы должны указать при помощи
<code>use</code>, что хотим это использовать.</p>
<span class='rusttest'>fn main() {
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
</pre>

<p>Как вы уже видели до этого, функция <code>main()</code> - это точка входа в нашу программу.
<code>fn</code> объявляет новую функцию. Пустые круглые скобки <code>()</code> показывают, что она не
принимает аргументов. Открывающая фигурная скобка <code>{</code> начинает тело нашей
функции. Из-за того, что мы не указали тип возвращаемого значения,
предполагается, что будет возвращаться <code>()</code> - пустой <a href="primitive-types.html#tuples">кортеж</a>.</p>
<span class='rusttest'>fn main() {
        println!(&quot;Угадайте число!&quot;);
    
        println!(&quot;Пожалуйста, введите предположение.&quot;);
    
}</span><pre class='rust rust-example-rendered'>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Угадайте число!&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Пожалуйста, введите предположение.&quot;</span>);
</pre>

<p>Мы уже изучили, что <code>println!()</code> - это <a href="macros.html">макрос</a>, который выводит
<a href="strings.html">строки</a> на экран.</p>
<span class='rusttest'>fn main() {
        let mut guess = String::new();
    
}</span><pre class='rust rust-example-rendered'>
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>guess</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
</pre>

<p>Теперь интереснее! Как же много всего происходит в этой строке! Первая вещь, на
которую следует обратить внимание - <a href="variable-bindings.html">выражение let</a>, которое используется
для <code>создания связи</code>. Оно выглядит так:</p>
<span class='rusttest'>fn main() {
    let foo = bar;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>foo</span> <span class='op'>=</span> <span class='ident'>bar</span>;
</pre>

<p>Это создаёт новую связь с именем <code>foo</code> и привязывает ей значение <code>bar</code>. Во
многих языках это называется <code>переменная</code>, но в Rust связывание переменных имеет
несколько трюков в рукаве.</p>

<p>Например, по умолчанию, связи <a href="mutability.html">неизменяемы</a>. По этой причине наш
пример использует <code>mut</code>: этот модификатор разрешает менять связь. С левой
стороны у <code>let</code> может быть не просто имя связи, а <a href="patterns.html">образец</a>. Мы будем
использовать их дальше. Их достаточно просто использовать:</p>
<span class='rusttest'>fn main() {
    let foo = 5; // неизменяемая связь
    let mut bar = 5; // изменяемая связь
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>foo</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// неизменяемая связь</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>bar</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// изменяемая связь</span>
</pre>

<p>Ах да, <code>//</code> начинает комментарий, который заканчивается в конце строки. Rust
игнорирует всё, что находится в <a href="comments.html">комментариях</a>.</p>

<p>Теперь мы знаем, что <code>let mut guess</code> объявляет изменяемую связь с именем
<code>guess</code>, а по другую сторону от <code>=</code> находится то, что будет привязано:
<code>String::new()</code>.</p>

<p><code>String</code> - это строковый тип, предоставляемый нам стандартной библиотекой.
<a href="http://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> - это текст в кодировке UTF-8 переменной длины.</p>

<p>Синтаксис <code>::new()</code> использует <code>::</code>, так как это привязанная к определённому
типу функция. То есть, она привязана к самому типу <code>String</code>, а не к определённой
переменной типа <code>String</code>. Некоторые языки называют это &quot;статическим методом&quot;.</p>

<p>Имя этой функции - <code>new()</code>, так как она создаёт новый, пустой <code>String</code>. Вы
можете найти эту функцию у многих типов, потому что это общее имя для создания
нового значения определённого типа.</p>

<p>Давайте посмотрим дальше:</p>
<span class='rusttest'>fn main() {
        io::stdin().read_line(&amp;mut guess)
            .ok()
            .expect(&quot;Не удалось прочитать строку&quot;);
    
}</span><pre class='rust rust-example-rendered'>
    <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>guess</span>)
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;Не удалось прочитать строку&quot;</span>);
</pre>

<p>Это уже побольше! Давайте это всё разберём. В первой строке есть две части.
Это первая:</p>
<span class='rusttest'>fn main() {
    io::stdin()
    
}</span><pre class='rust rust-example-rendered'>
<span class='ident'>io</span>::<span class='ident'>stdin</span>()
</pre>

<p>Помните, как мы импортировали (<code>use</code>) <code>std::io</code> в самом начале нашей программы?
Сейчас мы вызвали ассоциированную с ним функцию. Если бы мы не сделали <code>use std::io</code>, нам бы пришлось здесь написать <code>std::io::stdin()</code>.</p>

<p>Эта функция возвращает обработчик стандартного ввода нашего терминала. Более
подробно об это можно почитать в <a href="http://doc.rust-lang.org/std/io/struct.Stdin.html">std::io::Stdin</a>.</p>

<p>Следующая часть использует этот обработчик для получения всего, что введёт
пользователь:</p>
<span class='rusttest'>fn main() {
    .read_line(&amp;mut guess)
    
}</span><pre class='rust rust-example-rendered'>
.<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>guess</span>)
</pre>

<p>Здесь мы вызвали метод <a href="http://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line()</code></a> обработчика. <a href="methods.html">Методы</a>
похожи на привязанные функции, но доступны только у определённого экземпляра
типа, а не самого типа. Мы указали один аргумент функции <code>read_line()</code>: <code>&amp;mut guess</code>.</p>

<p>Помните, как мы выше привязали <code>guess</code>? Мы сказали, что она изменяема. Однако,
<code>read_line</code> не получает в качестве аргумента <code>String</code>: она получает <code>&amp;mut String</code>.  В Rust есть такая особенность, называемая <a href="references-and-borrowing.html">&quot;ссылки&quot;</a>,
которая позволяет нам иметь несколько ссылок на одни и так же данные, что
позволяет избежать излишнего их копирования. Ссылки - достаточно сложная
особенность, и одним из основных подкупающих достоинств Rust является то, как он
решает вопрос безопасности и простоты их использования. Пока что мы не должны
знать об этих деталях, чтобы завершить нашу программу. Сейчас, всё, что нам
нужно - это знать что ссылки, как и связывание при помощи <code>let</code>, неизменяемо по
умолчанию.  Следовательно, мы должны написать <code>&amp;mut guess</code>, а не <code>&amp;guess</code>.</p>

<p>Почему <code>read_line()</code> получает изменяемую ссылку на строку? Его работа - это
взять то, что пользователь написал в стандартный ввод, и положить это в
строку. Итак, функция получает строку в качестве аргумента, и для того, чтобы
добавить в эту строку что-то, она должна быть изменяемой.</p>

<p>Но мы пока что ещё не закончили с этой строкой кода. Пока это одна строка
текста, это только первая часть одной логической строки кода:</p>
<span class='rusttest'>fn main() {
            .ok()
            .expect(&quot;Не удалось прочитать строку&quot;);
    
}</span><pre class='rust rust-example-rendered'>
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;Не удалось прочитать строку&quot;</span>);
</pre>

<p>Когда мы вызываем метод, используя синтаксис <code>.foo()</code>, мы можем перенести вызов
в новую строку и сделать для него отступ. Это помогает работать с длинными
строками. Мы могли бы сделать и так:</p>
<span class='rusttest'>fn main() {
        io::stdin().read_line(&amp;mut guess).ok().expect(&quot;Не удалось прочитать строку&quot;);
    
}</span><pre class='rust rust-example-rendered'>
    <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>guess</span>).<span class='ident'>ok</span>().<span class='ident'>expect</span>(<span class='string'>&quot;Не удалось прочитать строку&quot;</span>);
</pre>

<p>Но это достаточно трудно читать. Поэтому мы разделили строку: по строке на
каждый вызов метода. Мы уже поговорили о <code>read_line()</code>, но ещё ничего не сказали
про <code>ok()</code> и <code>expect()</code>. Мы узнали, что <code>read_line()</code> передаёт всё, что
пользователь ввёл в <code>&amp;mut String</code>, которую мы ему передали. Но этот метод так же
и возвращает значение: в данном случае - <a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>. В стандартной
библиотеке Rust есть несколько типов с именем <code>Result</code>: общая версия
<a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> и несколько отдельных версий в подбиблиотеках, например
<code>io::Result</code>.</p>

<p>Целью типов <code>Result</code> является преобразование информации об ошибках, полученных
от обработчика. У значений типа <code>Result</code>, как и любого другого типа, есть
определённые для него методы. В данном случае, у <code>io::Result</code> имеется метод
<code>ok()</code>, который говорит, что &quot;мы хотим получить это значение, если всё прошло
хорошо.  Если это не так, выбрось сообщение об ошибке&quot;. Но зачем выбрасывать?
Для небольших программ, мы можем захотеть только вывести сообщение об ошибке и
прекратить выполнение программы. <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.ok">Метод <code>ok()</code></a> возвращает значение, у
которого объявлен другой метод: <code>expect()</code>. <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect">Метод <code>expect()</code></a> берёт
значение, для которого он вызван, и если оно не удачное, выполняет
<a href="error-handling.html"><code>panic!</code></a> со строкой, заданной методу в качестве аргумента. <code>panic!</code>
остановит нашу программу и выведет сообщение об ошибке.</p>

<p>Если мы выйдем за пределы этих двух методов, наша программа скомпилируется, но
мы получим следующее предупреждение:</p>

<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&amp;mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>

<p>Rust предупреждает, что мы не используем значение <code>Result</code>. Это предупреждение
пришло из специальной аннотации, которая указана в <code>io::Result</code>. Rust пытается
сказать нам, что мы не обрабатываем ошибки, которые могут возникнуть. Наиболее
правильным решением предотвращения ошибки будет её обработка. К счастью, если
мы только хотим обрушить приложение, если есть проблема, мы можем использовать
эти два небольших метода. Если мы можем восстановить что-либо из ошибки, мы
должны сделать что-либо другое, но мы сохраним это для будущего проекта.</p>

<p>Там всего одна строка из первого примера:</p>
<span class='rusttest'>fn main() {
        println!(&quot;Вы загадали: {}&quot;, guess);
    }
    
}</span><pre class='rust rust-example-rendered'>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Вы загадали: {}&quot;</span>, <span class='ident'>guess</span>);
}
</pre>

<p>Здесь выводится на экран строка, которая была получена с нашего ввода. <code>{}</code> -
это указатель места заполнения. В качестве второго аргумента макроса <code>println!</code>
мы указали <code>guess</code>. Если нам надо вывести несколько привязок, в самом простом
случае, мы должны поставить несколько указателей, по одному на каждую привязку:</p>
<span class='rusttest'>fn main() {
    let x = 5;
    let y = 10;
    
    println!(&quot;x и y: {} и {}&quot;, x, y);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x и y: {} и {}&quot;</span>, <span class='ident'>x</span>, <span class='ident'>y</span>);
</pre>

<p>Просто.</p>

<p>Мы можем запустить то, что у нас есть при помощи <code>cargo run</code>:</p>

<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Угадайте число!
Пожалуйста, введите предположение.
6
Вы загадали: 6
</code></pre>

<p>Всё правильно! Наша первая часть завершена: мы можем получать данные с
клавиатуры и потом печатать их на экран.</p>

<h1 id="Генерация-секретного-числа" class='section-header'><a
                           href="#Генерация-секретного-числа">Генерация секретного числа</a></h1>
<p>Далее, нам надо сгенерировать секретное число. В стандартной библиотеке Rust нет
ничего, что могло бы нам предоставить функционал для генерации случайных чисел.
Однако, разработчики Rust для этого предоставили <a href="https://crates.io/crates/rand">контейнер <code>rand</code></a>.
&quot;Контейнер&quot; - это пакет с кодом Rust. Наш проект - &quot;бинарный контейнер&quot;, из
которого в итоге получится исполняемый файл. <code>rand</code> - &quot;библиотечный контейнер&quot;,
который содержит код, предназначенный для использования с другими программами.</p>

<p>Прежде, чем мы начнём писать код с использованием <code>rand</code>, мы должны
модифицировать наш <code>Cargo.toml</code>. Откроем его и добавим в конец следующие
строчки:</p>

<pre><code class="language-toml">[dependencies]

rand=&quot;0.3.0&quot;
</code></pre>

<p>Секция <code>[dependencies]</code> похожа на секцию <code>[package]</code>: всё, что расположено после
объявления секции и до начала следующей, является частью этой секции. Cargo
использует секцию с зависимостями чтобы знать о том, какие сторонние контейнеры
потребуются, а так же какие их версии необходимы. В данном случае, мы используем
версию <code>0.3.0</code>. Cargo понимает <a href="http://semver.org/lang/ru">семантическое версионирование</a>, которое
является стандартом нумерации версий. Если мы хотим использовать последнюю
версию контейнера, мы можем использовать <code>*</code>. Так же мы можем указать
необходимый промежуток версий. В <a href="http://doc.crates.io/crates-io.html">документации Cargo</a> есть больше
информации.</p>

<p>Теперь, без каких-либо изменений в нашем коде, давайте соберём наш проект:</p>

<pre><code class="language-bash">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.8
 Downloading libc v0.1.6
   Compiling libc v0.1.6
   Compiling rand v0.3.8
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>

<p>(Конечно же, вы можете видеть другие версии.)</p>

<p>Lots of new output! Now that we have an external dependency, Cargo fetches the
latest versions of everything from the registry, which is a copy of data from
<a href="https://crates.io">Crates.io</a>. Crates.io is where people in the Rust ecosystem
post their open source Rust projects for others to use.</p>

<p>After updating the registry, Cargo checks our <code>[dependencies]</code> and downloads
any we don’t have yet. In this case, while we only said we wanted to depend on
<code>rand</code>, we’ve also grabbed a copy of <code>libc</code>. This is because <code>rand</code> depends on
<code>libc</code> to work. After downloading them, it compiles them, and then compiles
our project.</p>

<p>If we run <code>cargo build</code> again, we’ll get different output:</p>

<pre><code class="language-bash">$ cargo build
</code></pre>

<p>That’s right, no output! Cargo knows that our project has been built, and that
all of its dependencies are built, and so there’s no reason to do all that
stuff. With nothing to do, it simply exits. If we open up <code>src/main.rs</code> again,
make a trivial change, and then save it again, we’ll just see one line:</p>

<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>

<p>So, we told Cargo we wanted any <code>0.3.x</code> version of <code>rand</code>, and so it fetched the latest
version at the time this was written, <code>v0.3.8</code>. But what happens when next
week, version <code>v0.3.9</code> comes out, with an important bugfix? While getting
bugfixes is important, what if <code>0.3.9</code> contains a regression that breaks our
code?</p>

<p>The answer to this problem is the <code>Cargo.lock</code> file you’ll now find in your
project directory. When you build your project for the first time, Cargo
figures out all of the versions that fit your criteria, and then writes them
to the <code>Cargo.lock</code> file. When you build your project in the future, Cargo
will see that the <code>Cargo.lock</code> file exists, and then use that specific version
rather than do all the work of figuring out versions again. This lets you
have a repeatable build automatically. In other words, we’ll stay at <code>0.3.8</code>
until we explicitly upgrade, and so will anyone who we share our code with,
thanks to the lock file.</p>

<p>What about when we <em>do</em> want to use <code>v0.3.9</code>? Cargo has another command,
<code>update</code>, which says ‘ignore the lock, figure out all the latest versions that
fit what we’ve specified. If that works, write those versions out to the lock
file’. But, by default, Cargo will only look for versions larger than <code>0.3.0</code>
and smaller than <code>0.4.0</code>. If we want to move to <code>0.4.x</code>, we’d have to update
the <code>Cargo.toml</code> directly. When we do, the next time we <code>cargo build</code>, Cargo
will update the index and re-evaluate our <code>rand</code> requirements.</p>

<p>There’s a lot more to say about <a href="http://doc.crates.io">Cargo</a> and <a href="http://doc.crates.io/crates-io.html">its
ecosystem</a>, but for now, that’s all we need to know. Cargo makes
it really easy to re-use libraries, and so Rustaceans tend to write smaller
projects which are assembled out of a number of sub-packages.</p>

<p>Let’s get on to actually <em>using</em> <code>rand</code>. Here’s our next step:</p>
<span class='rusttest'>extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .ok()
        .expect(&quot;failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>guess</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>guess</span>)
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;failed to read line&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>guess</span>);
}
</pre>

<p>The first thing we’ve done is change the first line. It now says
<code>extern crate rand</code>. Because we declared <code>rand</code> in our <code>[dependencies]</code>, we
can use <code>extern crate</code> to let Rust know we’ll be making use of it. This also
does the equivalent of a <code>use rand;</code> as well, so we can make use of anything
in the <code>rand</code> crate by prefixing it with <code>rand::</code>.</p>

<p>Next, we added another <code>use</code> line: <code>use rand::Rng</code>. We’re going to use a
method in a moment, and it requires that <code>Rng</code> be in scope to work. The basic
idea is this: methods are defined on something called ‘traits’, and for the
method to work, it needs the trait to be in scope. For more about the
details, read the <a href="traits.html">traits</a> section.</p>

<p>There are two other lines we added, in the middle:</p>
<span class='rusttest'>fn main() {
        let secret_number = rand::thread_rng().gen_range(1, 101);
    
        println!(&quot;The secret number is: {}&quot;, secret_number);
    
}</span><pre class='rust rust-example-rendered'>
    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);
</pre>

<p>We use the <code>rand::thread_rng()</code> function to get a copy of the random number
generator, which is local to the particular <a href="concurrency.html">thread</a> of execution
we’re in. Because we <code>use rand::Rng</code>’d above, it has a <code>gen_range()</code> method
available. This method takes two arguments, and generates a number between
them. It’s inclusive on the lower bound, but exclusive on the upper bound,
so we need <code>1</code> and <code>101</code> to get a number between one and a hundred.</p>

<p>The second line just prints out the secret number. This is useful while
we’re developing our program, so we can easily test it out. But we’ll be
deleting it for the final version. It’s not much of a game if it prints out
the answer when you start it up!</p>

<p>Try running our new program a few times:</p>

<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>

<p>Great! Next up: let’s compare our guess to the secret guess.</p>

<h1 id="comparing-guesses" class='section-header'><a
                           href="#comparing-guesses">Comparing guesses</a></h1>
<p>Now that we’ve got user input, let’s compare our guess to the random guess.
Here’s our next step, though it doesn’t quite work yet:</p>
<span class='rusttest'>extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .ok()
        .expect(&quot;failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>guess</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>guess</span>)
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;failed to read line&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>guess</span>);

    <span class='kw'>match</span> <span class='ident'>guess</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>secret_number</span>) {
        <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
        <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
        <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>),
    }
}
</pre>

<p>A few new bits here. The first is another <code>use</code>. We bring a type called
<code>std::cmp::Ordering</code> into scope. Then, five new lines at the bottom that use
it:</p>
<span class='rusttest'>fn main() {
    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='ident'>guess</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>secret_number</span>) {
    <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
    <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
    <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>),
}
</pre>

<p>The <code>cmp()</code> method can be called on anything that can be compared, and it
takes a reference to the thing you want to compare it to. It returns the
<code>Ordering</code> type we <code>use</code>d earlier. We use a <a href="match.html"><code>match</code></a> statement to
determine exactly what kind of <code>Ordering</code> it is. <code>Ordering</code> is an
<a href="enums.html"><code>enum</code></a>, short for ‘enumeration’, which looks like this:</p>
<span class='rusttest'>fn main() {
    enum Foo {
        Bar,
        Baz,
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>Bar</span>,
    <span class='ident'>Baz</span>,
}
</pre>

<p>With this definition, anything of type <code>Foo</code> can be either a
<code>Foo::Bar</code> or a <code>Foo::Baz</code>. We use the <code>::</code> to indicate the
namespace for a particular <code>enum</code> variant.</p>

<p>The <a href="http://doc.rust-lang.org/std/cmp/enum.Ordering.html"><code>Ordering</code></a> enum has three possible variants: <code>Less</code>, <code>Equal</code>,
and <code>Greater</code>. The <code>match</code> statement takes a value of a type, and lets you
create an ‘arm’ for each possible value. Since we have three types of
<code>Ordering</code>, we have three arms:</p>
<span class='rusttest'>fn main() {
    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='ident'>guess</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>secret_number</span>) {
    <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
    <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
    <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>),
}
</pre>

<p>If it’s <code>Less</code>, we print <code>Too small!</code>, if it’s <code>Greater</code>, <code>Too big!</code>, and if
<code>Equal</code>, <code>You win!</code>. <code>match</code> is really useful, and is used often in Rust.</p>

<p>I did mention that this won’t quite work yet, though. Let’s try it:</p>

<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:28:21: 28:35 error: mismatched types:
 expected `&amp;collections::string::String`,
    found `&amp;_`
(expected struct `collections::string::String`,
    found integral variable) [E0308]
src/main.rs:28     match guess.cmp(&amp;secret_number) {
                                   ^~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>

<p>Whew! This is a big error. The core of it is that we have ‘mismatched types’.
Rust has a strong, static type system. However, it also has type inference.
When we wrote <code>let guess = String::new()</code>, Rust was able to infer that <code>guess</code>
should be a <code>String</code>, and so it doesn’t make us write out the type. And with
our <code>secret_number</code>, there are a number of types which can have a value
between one and a hundred: <code>i32</code>, a thirty-two-bit number, or <code>u32</code>, an
unsigned thirty-two-bit number, or <code>i64</code>, a sixty-four-bit number. Or others.
So far, that hasn’t mattered, and so Rust defaults to an <code>i32</code>. However, here,
Rust doesn’t know how to compare the <code>guess</code> and the <code>secret_number</code>. They
need to be the same type. Ultimately, we want to convert the <code>String</code> we
read as input into a real number type, for comparison. We can do that
with three more lines. Here’s our new program:</p>
<span class='rusttest'>extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .ok()
        .expect(&quot;failed to read line&quot;);

    let guess: u32 = guess.trim().parse()
        .ok()
        .expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>guess</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>guess</span>)
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;failed to read line&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>guess</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>guess</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>()
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;Please type a number!&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>guess</span>);

    <span class='kw'>match</span> <span class='ident'>guess</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>secret_number</span>) {
        <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
        <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
        <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>),
    }
}
</pre>

<p>The new three lines:</p>
<span class='rusttest'>fn main() {
        let guess: u32 = guess.trim().parse()
            .ok()
            .expect(&quot;Please type a number!&quot;);
    
}</span><pre class='rust rust-example-rendered'>
    <span class='kw'>let</span> <span class='ident'>guess</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>guess</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>()
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;Please type a number!&quot;</span>);
</pre>

<p>Wait a minute, I thought we already had a <code>guess</code>? We do, but Rust allows us
to ‘shadow’ the previous <code>guess</code> with a new one. This is often used in this
exact situation, where <code>guess</code> starts as a <code>String</code>, but we want to convert it
to an <code>u32</code>. Shadowing lets us re-use the <code>guess</code> name, rather than forcing us
to come up with two unique names like <code>guess_str</code> and <code>guess</code>, or something
else.</p>

<p>We bind <code>guess</code> to an expression that looks like something we wrote earlier:</p>
<span class='rusttest'>fn main() {
    guess.trim().parse()
    
}</span><pre class='rust rust-example-rendered'>
<span class='ident'>guess</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>()
</pre>

<p>Followed by an <code>ok().expect()</code> invocation. Here, <code>guess</code> refers to the old
<code>guess</code>, the one that was a <code>String</code> with our input in it. The <code>trim()</code>
method on <code>String</code>s will eliminate any white space at the beginning and end of
our string. This is important, as we had to press the ‘return’ key to satisfy
<code>read_line()</code>. This means that if we type <code>5</code> and hit return, <code>guess</code> looks
like this: <code>5\n</code>. The <code>\n</code> represents ‘newline’, the enter key. <code>trim()</code> gets
rid of this, leaving our string with just the <code>5</code>. The <a href="http://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code> method on
strings</a> parses a string into some kind of number. Since it can parse a
variety of numbers, we need to give Rust a hint as to the exact type of number
we want. Hence, <code>let guess: u32</code>. The colon (<code>:</code>) after <code>guess</code> tells Rust
we’re going to annotate its type. <code>u32</code> is an unsigned, thirty-two bit
integer. Rust has <a href="primitive-types.html#numeric-types">a number of built-in number types</a>, but we’ve
chosen <code>u32</code>. It’s a good default choice for a small positive number.</p>

<p>Just like <code>read_line()</code>, our call to <code>parse()</code> could cause an error. What if
our string contained <code>A👍%</code>? There’d be no way to convert that to a number. As
such, we’ll do the same thing we did with <code>read_line()</code>: use the <code>ok()</code> and
<code>expect()</code> methods to crash if there’s an error.</p>

<p>Let’s try our program out!</p>

<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>

<p>Nice! You can see I even added spaces before my guess, and it still figured
out that I guessed 76. Run the program a few times, and verify that guessing
the number works, as well as guessing a number too small.</p>

<p>Now we’ve got most of the game working, but we can only make one guess. Let’s
change that by adding loops!</p>

<h1 id="looping" class='section-header'><a
                           href="#looping">Looping</a></h1>
<p>The <code>loop</code> keyword gives us an infinite loop. Let’s add that in:</p>
<span class='rusttest'>extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .ok()
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = guess.trim().parse()
            .ok()
            .expect(&quot;Please type a number!&quot;);

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='kw'>loop</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>guess</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

        <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>guess</span>)
            .<span class='ident'>ok</span>()
            .<span class='ident'>expect</span>(<span class='string'>&quot;failed to read line&quot;</span>);

        <span class='kw'>let</span> <span class='ident'>guess</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>guess</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>()
            .<span class='ident'>ok</span>()
            .<span class='ident'>expect</span>(<span class='string'>&quot;Please type a number!&quot;</span>);

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>guess</span>);

        <span class='kw'>match</span> <span class='ident'>guess</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>secret_number</span>) {
            <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>),
        }
    }
}
</pre>

<p>And try it out. But wait, didn’t we just add an infinite loop? Yup. Remember
our discussion about <code>parse()</code>? If we give a non-number answer, we’ll <code>return</code>
and quit. Observe:</p>

<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread &#39;&lt;main&gt;&#39; panicked at &#39;Please type a number!&#39;
</code></pre>

<p>Ha! <code>quit</code> actually quits. As does any other non-number input. Well, this is
suboptimal to say the least. First, let’s actually quit when you win the game:</p>
<span class='rusttest'>extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .ok()
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = guess.trim().parse()
            .ok()
            .expect(&quot;Please type a number!&quot;);

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='kw'>loop</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>guess</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

        <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>guess</span>)
            .<span class='ident'>ok</span>()
            .<span class='ident'>expect</span>(<span class='string'>&quot;failed to read line&quot;</span>);

        <span class='kw'>let</span> <span class='ident'>guess</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>guess</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>()
            .<span class='ident'>ok</span>()
            .<span class='ident'>expect</span>(<span class='string'>&quot;Please type a number!&quot;</span>);

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>guess</span>);

        <span class='kw'>match</span> <span class='ident'>guess</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>secret_number</span>) {
            <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>);
                <span class='kw'>break</span>;
            }
        }
    }
}
</pre>

<p>By adding the <code>break</code> line after the <code>You win!</code>, we’ll exit the loop when we
win. Exiting the loop also means exiting the program, since it’s the last
thing in <code>main()</code>. We have just one more tweak to make: when someone inputs a
non-number, we don’t want to quit, we just want to ignore it. We can do that
like this:</p>
<span class='rusttest'>extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .ok()
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='kw'>loop</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>guess</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

        <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>guess</span>)
            .<span class='ident'>ok</span>()
            .<span class='ident'>expect</span>(<span class='string'>&quot;failed to read line&quot;</span>);

        <span class='kw'>let</span> <span class='ident'>guess</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>guess</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>() {
            <span class='prelude-val'>Ok</span>(<span class='ident'>num</span>) <span class='op'>=&gt;</span> <span class='ident'>num</span>,
            <span class='prelude-val'>Err</span>(_) <span class='op'>=&gt;</span> <span class='kw'>continue</span>,
        };

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>guess</span>);

        <span class='kw'>match</span> <span class='ident'>guess</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>secret_number</span>) {
            <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>);
                <span class='kw'>break</span>;
            }
        }
    }
}
</pre>

<p>These are the lines that changed:</p>
<span class='rusttest'>fn main() {
    let guess: u32 = match guess.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>guess</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>guess</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>() {
    <span class='prelude-val'>Ok</span>(<span class='ident'>num</span>) <span class='op'>=&gt;</span> <span class='ident'>num</span>,
    <span class='prelude-val'>Err</span>(_) <span class='op'>=&gt;</span> <span class='kw'>continue</span>,
};
</pre>

<p>This is how you generally move from ‘crash on error’ to ‘actually handle the
error’, by switching from <code>ok().expect()</code> to a <code>match</code> statement. The <code>Result</code>
returned by <code>parse()</code> is an enum just like <code>Ordering</code>, but in this case, each
variant has some data associated with it: <code>Ok</code> is a success, and <code>Err</code> is a
failure. Each contains more information: the successful parsed integer, or an
error type. In this case, we <code>match</code> on <code>Ok(num)</code>, which sets the inner value
of the <code>Ok</code> to the name <code>num</code>, and then we just return it on the right-hand
side. In the <code>Err</code> case, we don’t care what kind of error it is, so we just
use <code>_</code> instead of a name. This ignores the error, and <code>continue</code> causes us
to go to the next iteration of the <code>loop</code>.</p>

<p>Now we should be good! Let’s try:</p>

<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>

<p>Awesome! With one tiny last tweak, we have finished the guessing game. Can you
think of what it is? That’s right, we don’t want to print out the secret
number. It was good for testing, but it kind of ruins the game. Here’s our
final source:</p>
<span class='rusttest'>extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .ok()
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='kw'>loop</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>guess</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

        <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>guess</span>)
            .<span class='ident'>ok</span>()
            .<span class='ident'>expect</span>(<span class='string'>&quot;failed to read line&quot;</span>);

        <span class='kw'>let</span> <span class='ident'>guess</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>guess</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>() {
            <span class='prelude-val'>Ok</span>(<span class='ident'>num</span>) <span class='op'>=&gt;</span> <span class='ident'>num</span>,
            <span class='prelude-val'>Err</span>(_) <span class='op'>=&gt;</span> <span class='kw'>continue</span>,
        };

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>guess</span>);

        <span class='kw'>match</span> <span class='ident'>guess</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>secret_number</span>) {
            <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>);
                <span class='kw'>break</span>;
            }
        }
    }
}
</pre>

<h1 id="complete!" class='section-header'><a
                           href="#complete!">Complete!</a></h1>
<p>At this point, you have successfully built the Guessing Game! Congratulations!</p>

<p>This first project showed you a lot: <code>let</code>, <code>match</code>, methods, associated
functions, using external crates, and more. Our next project will show off
even more.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>