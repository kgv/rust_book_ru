<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Pointers</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='basic.html'><b>2.</b> Начальный Rust</a>
<ul class='section'>
<li><a href='installing-rust.html'><b>2.1.</b> Установка Rust</a>
</li>
<li><a href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
<li><a href='variable-bindings.html'><b>2.4.</b> Связывание переменных</a>
</li>
<li><a href='if.html'><b>2.5.</b> Условные переходы (If)</a>
</li>
<li><a href='functions.html'><b>2.6.</b> Функции</a>
</li>
<li><a href='comments.html'><b>2.7.</b> Комментарии</a>
</li>
<li><a href='compound-data-types.html'><b>2.8.</b> Агрегатные типы данных</a>
</li>
<li><a href='match.html'><b>2.9.</b> Сопоставление с образцом (Match)</a>
</li>
<li><a href='looping.html'><b>2.10.</b> Циклы</a>
</li>
<li><a href='strings.html'><b>2.11.</b> Строки</a>
</li>
<li><a href='arrays-vectors-and-slices.html'><b>2.12.</b> Массивы, вектора, срезы</a>
</li>
</ul>
</li>
<li><a href='intermediate.html'><b>3.</b> Средний Rust</a>
<ul class='section'>
<li><a href='crates-and-modules.html'><b>3.1.</b> Крейты и модули</a>
</li>
<li><a href='testing.html'><b>3.2.</b> Тестирование</a>
</li>
<li><a href='pointers.html'><b>3.3.</b> Указатели</a>
</li>
<li><a href='ownership.html'><b>3.4.</b> Владение</a>
</li>
<li><a href='more-strings.html'><b>3.5.</b> Больше о строках</a>
</li>
<li><a href='patterns.html'><b>3.6.</b> Шаблоны</a>
</li>
<li><a href='method-syntax.html'><b>3.7.</b> Синтаксис методов</a>
</li>
<li><a href='associated-types.html'><b>3.8.</b> Ассоциированные типы</a>
</li>
<li><a href='closures.html'><b>3.9.</b> Замыкания</a>
</li>
<li><a href='iterators.html'><b>3.10.</b> Итераторы</a>
</li>
<li><a href='generics.html'><b>3.11.</b> Дженерики</a>
</li>
<li><a href='traits.html'><b>3.12.</b> Трейты</a>
</li>
<li><a href='static-and-dynamic-dispatch.html'><b>3.13.</b> Статическая и динамическая диспетчерезация</a>
</li>
<li><a href='macros.html'><b>3.14.</b> Макросы</a>
</li>
<li><a href='concurrency.html'><b>3.15.</b> Многозадачность</a>
</li>
<li><a href='error-handling.html'><b>3.16.</b> Обработка ошибок</a>
</li>
<li><a href='documentation.html'><b>3.17.</b> Документация</a>
</li>
</ul>
</li>
<li><a href='advanced.html'><b>4.</b> Продвинутый Rust</a>
<ul class='section'>
<li><a href='ffi.html'><b>4.1.</b> Интерфейс внешних функций (FFI)</a>
</li>
<li><a href='unsafe.html'><b>4.2.</b> Небезопасный код</a>
</li>
<li><a href='advanced-macros.html'><b>4.3.</b> Продвинутые макросы</a>
</li>
</ul>
</li>
<li><a href='unstable.html'><b>5.</b> Нестабильный Rust</a>
<ul class='section'>
<li><a href='plugins.html'><b>5.1.</b> Плагины компилятора</a>
</li>
<li><a href='inline-assembly.html'><b>5.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a href='no-stdlib.html'><b>5.3.</b> Без stdlib</a>
</li>
<li><a href='intrinsics.html'><b>5.4.</b> Intrinsics</a>
</li>
<li><a href='lang-items.html'><b>5.5.</b> Lang items</a>
</li>
<li><a href='link-args.html'><b>5.6.</b> Link args</a>
</li>
</ul>
</li>
<li><a href='conclusion.html'><b>6.</b> Заключение</a>
</li>
<li><a href='glossary.html'><b>7.</b> Глоссарий</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Pointers</h1>
    <p>Rust&#39;s pointers are one of its more unique and compelling features. Pointers
are also one of the more confusing topics for newcomers to Rust. They can also
be confusing for people coming from other languages that support pointers, such
as C++. This guide will help you understand this important topic.</p>

<p>Be sceptical of non-reference pointers in Rust: use them for a deliberate
purpose, not just to make the compiler happy. Each pointer type comes with an
explanation about when they are appropriate to use. Default to references
unless you&#39;re in one of those specific situations.</p>

<p>You may be interested in the <a href="#cheat-sheet">cheat sheet</a>, which gives a quick
overview of the types, names, and purpose of the various pointers.</p>

<h1 id="an-introduction" class='section-header'><a
                           href="#an-introduction">An introduction</a></h1>
<p>If you aren&#39;t familiar with the concept of pointers, here&#39;s a short
introduction.  Pointers are a very fundamental concept in systems programming
languages, so it&#39;s important to understand them.</p>

<h2 id="pointer-basics" class='section-header'><a
                           href="#pointer-basics">Pointer Basics</a></h2>
<p>When you create a new variable binding, you&#39;re giving a name to a value that&#39;s
stored at a particular location on the stack. (If you&#39;re not familiar with the
<em>heap</em> vs. <em>stack</em>, please check out <a href="http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap">this Stack Overflow
question</a>,
as the rest of this guide assumes you know the difference.) Like this:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>8</span>;
</pre>

<table><thead>
<tr>
<th>location</th>
<th>value</th>
</tr>
</thead><tbody>
<tr>
<td>0xd3e030</td>
<td>5</td>
</tr>
<tr>
<td>0xd3e028</td>
<td>8</td>
</tr>
</tbody></table>

<p>We&#39;re making up memory locations here, they&#39;re just sample values. Anyway, the
point is that <code>x</code>, the name we&#39;re using for our variable, corresponds to the
memory location <code>0xd3e030</code>, and the value at that location is <code>5</code>. When we
refer to <code>x</code>, we get the corresponding value. Hence, <code>x</code> is <code>5</code>.</p>

<p>Let&#39;s introduce a pointer. In some languages, there is just one type of
&#39;pointer,&#39; but in Rust, we have many types. In this case, we&#39;ll use a Rust
<em>reference</em>, which is the simplest kind of pointer.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>8</span>;
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>y</span>;
</pre>

<table><thead>
<tr>
<th>location</th>
<th>value</th>
</tr>
</thead><tbody>
<tr>
<td>0xd3e030</td>
<td>5</td>
</tr>
<tr>
<td>0xd3e028</td>
<td>8</td>
</tr>
<tr>
<td>0xd3e020</td>
<td>0xd3e028</td>
</tr>
</tbody></table>

<p>See the difference? Rather than contain a value, the value of a pointer is a
location in memory. In this case, the location of <code>y</code>. <code>x</code> and <code>y</code> have the
type <code>i32</code>, but <code>z</code> has the type <code>&amp;i32</code>. We can print this location using the
<code>{:p}</code> format string:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>8</span>;
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>y</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:p}&quot;</span>, <span class='ident'>z</span>);
</pre>

<p>This would print <code>0xd3e028</code>, with our fictional memory addresses.</p>

<p>Because <code>i32</code> and <code>&amp;i32</code> are different types, we can&#39;t, for example, add them
together:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>8</span>;
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>y</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>z</span>);
</pre>

<p>This gives us an error:</p>

<pre><code class="language-text">hello.rs:6:24: 6:25 error: mismatched types: expected `_`, found `&amp;_` (expected integral variable, found &amp;-ptr)
hello.rs:6     println!(&quot;{}&quot;, x + z);
                                  ^
</code></pre>

<p>We can <em>dereference</em> the pointer by using the <code>*</code> operator. Dereferencing a
pointer means accessing the value at the location stored in the pointer. This
will work:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>8</span>;
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>y</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='op'>*</span><span class='ident'>z</span>);
</pre>

<p>It prints <code>13</code>.</p>

<p>That&#39;s it! That&#39;s all pointers are: they point to some memory location. Not
much else to them. Now that we&#39;ve discussed the <em>what</em> of pointers, let&#39;s
talk about the <em>why</em>.</p>

<h2 id="pointer-uses" class='section-header'><a
                           href="#pointer-uses">Pointer uses</a></h2>
<p>Rust&#39;s pointers are quite useful, but in different ways than in other systems
languages. We&#39;ll talk about best practices for Rust pointers later in
the guide, but here are some ways that pointers are useful in other languages:</p>

<p>In C, strings are a pointer to a list of <code>char</code>s, ending with a null byte.
The only way to use strings is to get quite familiar with pointers.</p>

<p>Pointers are useful to point to memory locations that are not on the stack. For
example, our example used two stack variables, so we were able to give them
names. But if we allocated some heap memory, we wouldn&#39;t have that name
available.  In C, <code>malloc</code> is used to allocate heap memory, and it returns a
pointer.</p>

<p>As a more general variant of the previous two points, any time you have a
structure that can change in size, you need a pointer. You can&#39;t tell at
compile time how much memory to allocate, so you&#39;ve gotta use a pointer to
point at the memory where it will be allocated, and deal with it at run time.</p>

<p>Pointers are useful in languages that are pass-by-value, rather than
pass-by-reference. Basically, languages can make two choices (this is made
up syntax, it&#39;s not Rust):</p>

<pre><code class="language-text">func foo(x) {
    x = 5
}

func main() {
    i = 1
    foo(i)
    // what is the value of i here?
}
</code></pre>

<p>In languages that are pass-by-value, <code>foo</code> will get a copy of <code>i</code>, and so
the original version of <code>i</code> is not modified. At the comment, <code>i</code> will still be
<code>1</code>. In a language that is pass-by-reference, <code>foo</code> will get a reference to <code>i</code>,
and therefore, can change its value. At the comment, <code>i</code> will be <code>5</code>.</p>

<p>So what do pointers have to do with this? Well, since pointers point to a
location in memory...</p>

<pre><code class="language-text">func foo(&amp;i32 x) {
    *x = 5
}

func main() {
    i = 1
    foo(&amp;i)
    // what is the value of i here?
}
</code></pre>

<p>Even in a language which is pass by value, <code>i</code> will be <code>5</code> at the comment. You
see, because the argument <code>x</code> is a pointer, we do send a copy over to <code>foo</code>,
but because it points at a memory location, which we then assign to, the
original value is still changed. This pattern is called
<em>pass-reference-by-value</em>. Tricky!</p>

<h2 id="common-pointer-problems" class='section-header'><a
                           href="#common-pointer-problems">Common pointer problems</a></h2>
<p>We&#39;ve talked about pointers, and we&#39;ve sung their praises. So what&#39;s the
downside? Well, Rust attempts to mitigate each of these kinds of problems,
but here are problems with pointers in other languages:</p>

<p>Uninitialized pointers can cause a problem. For example, what does this program
do?</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw-2'>&amp;</span><span class='ident'>int</span> <span class='ident'>x</span>;
<span class='op'>*</span><span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// whoops!</span>
</pre>

<p>Who knows? We just declare a pointer, but don&#39;t point it at anything, and then
set the memory location that it points at to be <code>5</code>. But which location? Nobody
knows. This might be harmless, and it might be catastrophic.</p>

<p>When you combine pointers and functions, it&#39;s easy to accidentally invalidate
the memory the pointer is pointing to. For example:</p>

<pre><code class="language-text">func make_pointer(): &amp;int {
    x = 5;

    return &amp;x;
}

func main() {
    &amp;int i = make_pointer();
    *i = 5; // uh oh!
}
</code></pre>

<p><code>x</code> is local to the <code>make_pointer</code> function, and therefore, is invalid as soon
as <code>make_pointer</code> returns. But we return a pointer to its memory location, and
so back in <code>main</code>, we try to use that pointer, and it&#39;s a very similar
situation to our first one. Setting invalid memory locations is bad.</p>

<p>As one last example of a big problem with pointers, <em>aliasing</em> can be an
issue. Two pointers are said to alias when they point at the same location
in memory. Like this:</p>

<pre><code class="language-text">func mutate(&amp;int i, int j) {
    *i = j;
}

func main() {
  x = 5;
  y = &amp;x;
  z = &amp;x; //y and z are aliased


  run_in_new_thread(mutate, y, 1);
  run_in_new_thread(mutate, z, 100);

  // what is the value of x here?
}
</code></pre>

<p>In this made-up example, <code>run_in_new_thread</code> spins up a new thread, and calls
the given function name with its arguments. Since we have two threads, and
they&#39;re both operating on aliases to <code>x</code>, we can&#39;t tell which one finishes
first, and therefore, the value of <code>x</code> is actually non-deterministic. Worse,
what if one of them had invalidated the memory location they pointed to? We&#39;d
have the same problem as before, where we&#39;d be setting an invalid location.</p>

<h2 id="conclusion" class='section-header'><a
                           href="#conclusion">Conclusion</a></h2>
<p>That&#39;s a basic overview of pointers as a general concept. As we alluded to
before, Rust has different kinds of pointers, rather than just one, and
mitigates all of the problems that we talked about, too. This does mean that
Rust pointers are slightly more complicated than in other languages, but
it&#39;s worth it to not have the problems that simple pointers have.</p>

<h1 id="references" class='section-header'><a
                           href="#references">References</a></h1>
<p>The most basic type of pointer that Rust has is called a <em>reference</em>. Rust
references look like this:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='op'>*</span><span class='ident'>y</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:p}&quot;</span>, <span class='ident'>y</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>y</span>);
</pre>

<p>We&#39;d say &quot;<code>y</code> is a reference to <code>x</code>.&quot; The first <code>println!</code> prints out the
value of <code>y</code>&#39;s referent by using the dereference operator, <code>*</code>. The second
one prints out the memory location that <code>y</code> points to, by using the pointer
format string. The third <code>println!</code> <em>also</em> prints out the value of <code>y</code>&#39;s
referent, because <code>println!</code> will automatically dereference it for us.</p>

<p>Here&#39;s a function that takes a reference:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>succ</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='op'>*</span><span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }
</pre>

<p>You can also use <code>&amp;</code> as an operator to create a reference, so we can
call this function in two different ways:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>succ</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='op'>*</span><span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {

    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>succ</span>(<span class='ident'>y</span>));
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>succ</span>(<span class='kw-2'>&amp;</span><span class='ident'>x</span>));
}
</pre>

<p>Both of these <code>println!</code>s will print out <code>6</code>.</p>

<p>Of course, if this were real code, we wouldn&#39;t bother with the reference, and
just write:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>succ</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }
</pre>

<p>References are immutable by default:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>;

<span class='op'>*</span><span class='ident'>y</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// error: cannot assign to immutable borrowed content `*y`</span>
</pre>

<p>They can be made mutable with <code>mut</code>, but only if its referent is also mutable.
This works:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>;
</pre>

<p>This does not:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>; <span class='comment'>// error: cannot borrow immutable local variable `x` as mutable</span>
</pre>

<p>Immutable pointers are allowed to alias:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>;
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>;
</pre>

<p>Mutable ones, however, are not:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>;
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>; <span class='comment'>// error: cannot borrow `x` as mutable more than once at a time</span>
</pre>

<p>Despite their complete safety, a reference&#39;s representation at runtime is the
same as that of an ordinary pointer in a C program. They introduce zero
overhead. The compiler does all safety checks at compile time. The theory that
allows for this was originally called <em>region pointers</em>. Region pointers
evolved into what we know today as <em>lifetimes</em>.</p>

<p>Here&#39;s the simple explanation: would you expect this code to compile?</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
}
</pre>

<p>Probably not. That&#39;s because you know that the name <code>x</code> is valid from where
it&#39;s declared to when it goes out of scope. In this case, that&#39;s the end of
the <code>main</code> function. So you know this code will cause an error. We call this
duration a <em>lifetime</em>. Let&#39;s try a more complex example:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&lt;</span> <span class='number'>10</span> {
        <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>;

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Oh no: {}&quot;</span>, <span class='ident'>y</span>);
        <span class='kw'>return</span>;
    }

    <span class='ident'>x</span> <span class='op'>-=</span> <span class='number'>1</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Oh no: {}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>Here, we&#39;re borrowing a pointer to <code>x</code> inside of the <code>if</code>. The compiler, however,
is able to determine that that pointer will go out of scope without <code>x</code> being
mutated, and therefore, lets us pass. This wouldn&#39;t work:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&lt;</span> <span class='number'>10</span> {
        <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>;

        <span class='ident'>x</span> <span class='op'>-=</span> <span class='number'>1</span>;

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Oh no: {}&quot;</span>, <span class='ident'>y</span>);
        <span class='kw'>return</span>;
    }

    <span class='ident'>x</span> <span class='op'>-=</span> <span class='number'>1</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Oh no: {}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>It gives this error:</p>

<pre><code class="language-text">test.rs:7:9: 7:15 error: cannot assign to `x` because it is borrowed
test.rs:7         x -= 1;
                  ^~~~~~
test.rs:5:18: 5:19 note: borrow of `x` occurs here
test.rs:5         let y = &amp;x;
                           ^
</code></pre>

<p>As you might guess, this kind of analysis is complex for a human, and therefore
hard for a computer, too! There is an entire <a href="ownership.html">guide devoted to references, ownership,
and lifetimes</a> that goes into this topic in
great detail, so if you want the full details, check that out.</p>

<h2 id="best-practices" class='section-header'><a
                           href="#best-practices">Best practices</a></h2>
<p>In general, prefer stack allocation over heap allocation. Using references to
stack allocated information is preferred whenever possible. Therefore,
references are the default pointer type you should use, unless you have a
specific reason to use a different type. The other types of pointers cover when
they&#39;re appropriate to use in their own best practices sections.</p>

<p>Use references when you want to use a pointer, but do not want to take ownership.
References just borrow ownership, which is more polite if you don&#39;t need the
ownership. In other words, prefer:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>succ</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='op'>*</span><span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }
</pre>

<p>to</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>succ</span>(<span class='ident'>x</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='op'>*</span><span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }
</pre>

<p>As a corollary to that rule, references allow you to accept a wide variety of
other pointers, and so are useful so that you don&#39;t have to write a number
of variants per pointer. In other words, prefer:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>succ</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='op'>*</span><span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }
</pre>

<p>to</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rc</span>::<span class='ident'>Rc</span>;

<span class='kw'>fn</span> <span class='ident'>box_succ</span>(<span class='ident'>x</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='op'>*</span><span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }

<span class='kw'>fn</span> <span class='ident'>rc_succ</span>(<span class='ident'>x</span>: <span class='ident'>Rc</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='op'>*</span><span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }
</pre>

<p>Note that the caller of your function will have to modify their calls slightly:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rc</span>::<span class='ident'>Rc</span>;

<span class='kw'>fn</span> <span class='ident'>succ</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='op'>*</span><span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }

<span class='kw'>let</span> <span class='ident'>ref_x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>box_x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>5</span>);
<span class='kw'>let</span> <span class='ident'>rc_x</span> <span class='op'>=</span> <span class='ident'>Rc</span>::<span class='ident'>new</span>(<span class='number'>5</span>);

<span class='ident'>succ</span>(<span class='ident'>ref_x</span>);
<span class='ident'>succ</span>(<span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>box_x</span>);
<span class='ident'>succ</span>(<span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>rc_x</span>);
</pre>

<p>The initial <code>*</code> dereferences the pointer, and then <code>&amp;</code> takes a reference to
those contents.</p>

<h1 id="boxes" class='section-header'><a
                           href="#boxes">Boxes</a></h1>
<p><code>Box&lt;T&gt;</code> is Rust&#39;s <em>boxed pointer</em> type. Boxes provide the simplest form of
heap allocation in Rust. Creating a box looks like this:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>5</span>);
</pre>

<p>Boxes are heap allocated and they are deallocated automatically by Rust when
they go out of scope:</p>
<pre id='rust-example-rendered' class='rust '>
{
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>5</span>);

    <span class='comment'>// stuff happens</span>

} <span class='comment'>// x is destructed and its memory is free&#39;d here</span>
</pre>

<p>However, boxes do <em>not</em> use reference counting or garbage collection. Boxes are
what&#39;s called an <em>affine type</em>. This means that the Rust compiler, at compile
time, determines when the box comes into and goes out of scope, and inserts the
appropriate calls there.</p>

<p>You don&#39;t need to fully grok the theory of affine types to grok boxes, though.
As a rough approximation, you can treat this Rust code:</p>
<pre id='rust-example-rendered' class='rust '>
{
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>5</span>);

    <span class='comment'>// stuff happens</span>
}
</pre>

<p>As being similar to this C code:</p>

<pre><code class="language-c">{
    int *x;
    x = (int *)malloc(sizeof(int));
    *x = 5;

    // stuff happens

    free(x);
}
</code></pre>

<p>Of course, this is a 10,000 foot view. It leaves out destructors, for example.
But the general idea is correct: you get the semantics of <code>malloc</code>/<code>free</code>, but
with some improvements:</p>

<ol>
<li>It&#39;s impossible to allocate the incorrect amount of memory, because Rust
figures it out from the types.</li>
<li>You cannot forget to <code>free</code> memory you&#39;ve allocated, because Rust does it
for you.</li>
<li>Rust ensures that this <code>free</code> happens at the right time, when it is truly
not used. Use-after-free is not possible.</li>
<li>Rust enforces that no other writeable pointers alias to this heap memory,
which means writing to an invalid pointer is not possible.</li>
</ol>

<p>See the section on references or the <a href="ownership.html">ownership guide</a>
for more detail on how lifetimes work.</p>

<p>Using boxes and references together is very common. For example:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>add_one</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='op'>*</span><span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>5</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>add_one</span>(<span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>x</span>));
}
</pre>

<p>In this case, Rust knows that <code>x</code> is being <em>borrowed</em> by the <code>add_one()</code>
function, and since it&#39;s only reading the value, allows it.</p>

<p>We can borrow <code>x</code> as read-only multiple times, even simultaneously:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>add</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='op'>*</span><span class='ident'>x</span> <span class='op'>+</span> <span class='op'>*</span><span class='ident'>y</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>5</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>add</span>(<span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>x</span>, <span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>x</span>));
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>add</span>(<span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>x</span>, <span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>x</span>));
}
</pre>

<p>We can mutably borrow <code>x</code> multiple times, but only if x itself is mutable, and
it may not be <em>simultaneously</em> borrowed: </p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>increment</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>i32</span>) {
    <span class='op'>*</span><span class='ident'>x</span> <span class='op'>+=</span> <span class='number'>1</span>;
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// If variable x is not &quot;mut&quot;, this will not compile</span>
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>5</span>);

    <span class='ident'>increment</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>);
    <span class='ident'>increment</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>Notice the signature of <code>increment()</code> requests a mutable reference.</p>

<h2 id="best-practices-1" class='section-header'><a
                           href="#best-practices-1">Best practices</a></h2>
<p>Boxes are appropriate to use in two situations: Recursive data structures,
and occasionally, when returning data.</p>

<h3 id="recursive-data-structures" class='section-header'><a
                           href="#recursive-data-structures">Recursive data structures</a></h3>
<p>Sometimes, you need a recursive data structure. The simplest is known as a
<em>cons list</em>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>Cons</span>(<span class='ident'>T</span>, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span>),
    <span class='ident'>Nil</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>list</span>: <span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>List</span>::<span class='ident'>Cons</span>(<span class='number'>1</span>, <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>List</span>::<span class='ident'>Cons</span>(<span class='number'>2</span>, <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>List</span>::<span class='ident'>Cons</span>(<span class='number'>3</span>, <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>List</span>::<span class='ident'>Nil</span>))))));
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>list</span>);
}
</pre>

<p>This prints:</p>

<pre><code class="language-text">Cons(1, Box(Cons(2, Box(Cons(3, Box(Nil))))))
</code></pre>

<p>The reference to another <code>List</code> inside of the <code>Cons</code> enum variant must be a box,
because we don&#39;t know the length of the list. Because we don&#39;t know the length,
we don&#39;t know the size, and therefore, we need to heap allocate our list.</p>

<p>Working with recursive or other unknown-sized data structures is the primary
use-case for boxes.</p>

<h3 id="returning-data" class='section-header'><a
                           href="#returning-data">Returning data</a></h3>
<p>This is important enough to have its own section entirely. The TL;DR is this:
you don&#39;t want to return pointers, even when you might in a language like C or
C++.</p>

<p>See <a href="#returning-pointers">Returning Pointers</a> below for more.</p>

<h1 id="rc-and-arc" class='section-header'><a
                           href="#rc-and-arc">Rc and Arc</a></h1>
<p>This part is coming soon.</p>

<h2 id="best-practices-2" class='section-header'><a
                           href="#best-practices-2">Best practices</a></h2>
<p>This part is coming soon.</p>

<h1 id="raw-pointers" class='section-header'><a
                           href="#raw-pointers">Raw Pointers</a></h1>
<p>This part is coming soon.</p>

<h2 id="best-practices-3" class='section-header'><a
                           href="#best-practices-3">Best practices</a></h2>
<p>This part is coming soon.</p>

<h1 id="returning-pointers" class='section-header'><a
                           href="#returning-pointers">Returning Pointers</a></h1>
<p>In many languages with pointers, you&#39;d return a pointer from a function
so as to avoid copying a large data structure. For example:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>BigStruct</span> {
    <span class='ident'>one</span>: <span class='ident'>i32</span>,
    <span class='ident'>two</span>: <span class='ident'>i32</span>,
    <span class='comment'>// etc</span>
    <span class='ident'>one_hundred</span>: <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>BigStruct</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>BigStruct</span><span class='op'>&gt;</span> {
    <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='op'>*</span><span class='ident'>x</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>BigStruct</span> {
        <span class='ident'>one</span>: <span class='number'>1</span>,
        <span class='ident'>two</span>: <span class='number'>2</span>,
        <span class='ident'>one_hundred</span>: <span class='number'>100</span>,
    });

    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>foo</span>(<span class='ident'>x</span>);
}
</pre>

<p>The idea is that by passing around a box, you&#39;re only copying a pointer, rather
than the hundred <code>int</code>s that make up the <code>BigStruct</code>.</p>

<p>This is an antipattern in Rust. Instead, write this:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>box_syntax</span>)]</span>

<span class='kw'>struct</span> <span class='ident'>BigStruct</span> {
    <span class='ident'>one</span>: <span class='ident'>i32</span>,
    <span class='ident'>two</span>: <span class='ident'>i32</span>,
    <span class='comment'>// etc</span>
    <span class='ident'>one_hundred</span>: <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>BigStruct</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>BigStruct</span> {
    <span class='op'>*</span><span class='ident'>x</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>BigStruct</span> {
        <span class='ident'>one</span>: <span class='number'>1</span>,
        <span class='ident'>two</span>: <span class='number'>2</span>,
        <span class='ident'>one_hundred</span>: <span class='number'>100</span>,
    });

    <span class='kw'>let</span> <span class='ident'>y</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>BigStruct</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>foo</span>(<span class='ident'>x</span>);
}
</pre>

<p>Note that this uses the <code>box_syntax</code> feature gate, so this syntax may change in
the future.</p>

<p>This gives you flexibility without sacrificing performance.</p>

<p>You may think that this gives us terrible performance: return a value and then
immediately box it up ?! Isn&#39;t this pattern the worst of both worlds? Rust is
smarter than that. There is no copy in this code. <code>main</code> allocates enough room
for the <code>box</code>, passes a pointer to that memory into <code>foo</code> as <code>x</code>, and then
<code>foo</code> writes the value straight into the <code>Box&lt;T&gt;</code>.</p>

<p>This is important enough that it bears repeating: pointers are not for
optimizing returning values from your code. Allow the caller to choose how they
want to use your output.</p>

<h1 id="creating-your-own-pointers" class='section-header'><a
                           href="#creating-your-own-pointers">Creating your own Pointers</a></h1>
<p>This part is coming soon.</p>

<h2 id="best-practices-4" class='section-header'><a
                           href="#best-practices-4">Best practices</a></h2>
<p>This part is coming soon.</p>

<h1 id="patterns-and-ref" class='section-header'><a
                           href="#patterns-and-ref">Patterns and <code>ref</code></a></h1>
<p>When you&#39;re trying to match something that&#39;s stored in a pointer, there may be
a situation where matching directly isn&#39;t the best option available. Let&#39;s see
how to properly handle this:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>possibly_print</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span>) {
    <span class='kw'>match</span> <span class='op'>*</span><span class='ident'>x</span> {
        <span class='comment'>// BAD: cannot move out of a `&amp;`</span>
        <span class='prelude-val'>Some</span>(<span class='ident'>s</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>)

        <span class='comment'>// GOOD: instead take a reference into the memory of the `Option`</span>
        <span class='prelude-val'>Some</span>(<span class='kw-2'>ref</span> <span class='ident'>s</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='op'>*</span><span class='ident'>s</span>),
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> {}
    }
}
</pre>

<p>The <code>ref s</code> here means that <code>s</code> will be of type <code>&amp;String</code>, rather than type
<code>String</code>.</p>

<p>This is important when the type you&#39;re trying to get access to has a destructor
and you don&#39;t want to move it, you just want a reference to it.</p>

<h1 id="cheat-sheet" class='section-header'><a
                           href="#cheat-sheet">Cheat Sheet</a></h1>
<p>Here&#39;s a quick rundown of Rust&#39;s pointer types:</p>

<table><thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>Summary</th>
</tr>
</thead><tbody>
<tr>
<td><code>&amp;T</code></td>
<td>Reference</td>
<td>Allows one or more references to read <code>T</code></td>
</tr>
<tr>
<td><code>&amp;mut T</code></td>
<td>Mutable Reference</td>
<td>Allows a single reference to read and write <code>T</code></td>
</tr>
<tr>
<td><code>Box&lt;T&gt;</code></td>
<td>Box</td>
<td>Heap allocated <code>T</code> with a single owner that may read and write <code>T</code>.</td>
</tr>
<tr>
<td><code>Rc&lt;T&gt;</code></td>
<td>&quot;arr cee&quot; pointer</td>
<td>Heap allocated <code>T</code> with many readers</td>
</tr>
<tr>
<td><code>Arc&lt;T&gt;</code></td>
<td>Arc pointer</td>
<td>Same as above, but safe sharing across threads</td>
</tr>
<tr>
<td><code>*const T</code></td>
<td>Raw pointer</td>
<td>Unsafe read access to <code>T</code></td>
</tr>
<tr>
<td><code>*mut T</code></td>
<td>Mutable raw pointer</td>
<td>Unsafe read and write access to <code>T</code></td>
</tr>
</tbody></table>

<h1 id="related-resources" class='section-header'><a
                           href="#related-resources">Related resources</a></h1>
<ul>
<li><a href="../std/boxed/index.html">API documentation for Box</a></li>
<li><a href="ownership.html">Ownership guide</a></li>
<li><a href="http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf">Cyclone paper on regions</a>, which inspired Rust&#39;s lifetime system</li>
</ul>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
</div></div>


</body>
</html>